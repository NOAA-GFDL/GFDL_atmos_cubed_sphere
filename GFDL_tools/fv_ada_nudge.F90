!***********************************************************************
!*                   GNU Lesser General Public License
!*
!* This file is part of the FV3 dynamical core.
!*
!* The FV3 dynamical core is free software: you can redistribute it
!* and/or modify it under the terms of the
!* GNU Lesser General Public License as published by the
!* Free Software Foundation, either version 3 of the License, or
!* (at your option) any later version.
!*
!* The FV3 dynamical core is distributed in the hope that it will be
!* useful, but WITHOUT ANY WARRANTY; without even the implied warranty
!* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!* See the GNU General Public License for more details.
!*
!* You should have received a copy of the GNU Lesser General Public
!* License along with the FV3 dynamical core.
!* If not, see <http://www.gnu.org/licenses/>.
!***********************************************************************
#ifdef OVERLOAD_R4
#define _GET_VAR1 get_var1_real
#else
#define _GET_VAR1 get_var1_double
#endif
module fv_ada_nudge_mod
  ! This fv_ada_nudge_mod module is based off the existing fv_nwp_nudge_mod found
  ! in the fv_nudge.F90 file in the same directory as this file.
  !
  ! fv_ada_nudge_mod is modified only that it calls the ADA routines for data
  ! assimilation.

!!! CLEANUP: This file compiles but has not been tested.

!!! CLEANUP: Also see  /ncrc/home1/Lucas.Harris/forecast/AM2p12b/quebec/input_quebec/hiram_quebec_updates/fv_nudge.F90 for auto-inputs
!!! (copy added in this directory: see fv_nudge.F90-auto )

 use external_sst_mod,  only: i_sst, j_sst, sst_ncep, sst_anom, forecast_mode
 use diag_manager_mod,  only: register_diag_field, send_data
 use constants_mod,     only: pi, grav, rdgas, cp_air, kappa, cnst_radius=>radius, seconds_per_day
 use fms_mod,           only: write_version_number, check_nml_error
 use mpp_mod,           only: mpp_error, FATAL, stdlog, get_unit, mpp_pe, input_nml_file
 use mpp_mod,           only: mpp_root_pe, stdout ! snz
 use mpp_mod,           only: CLOCK_COMPONENT, CLOCK_SUBCOMPONENT, CLOCK_MODULE, CLOCK_ROUTINE
 use mpp_domains_mod,   only: mpp_update_domains, domain2d
 use mpp_domains_mod,   only: mpp_get_data_domain ! snz
 use time_manager_mod,  only: time_type,  get_time, get_date, set_date, increment_time

 use grid2_mod, only : define_cube_mosaic ! snz

 use fv_grid_utils_mod, only: great_circle_dist, intp_great_circle
 use fv_grid_utils_mod, only: latlon2xyz, vect_cross, normalize_vect
 use fv_diagnostics_mod,only: prt_maxmin, fv_time
 use tp_core_mod,       only: copy_corners
 use fv_mapz_mod,       only: mappm
 use fv_mp_mod,         only: mp_reduce_sum, mp_reduce_min, mp_reduce_max, is_master
 use fv_timing_mod,     only: timing_on, timing_off

 use sim_nc_mod,        only: open_ncfile, close_ncfile, get_ncdim1, get_var1_double, &
                              get_var3_r4, get_var2_r4, get_var1_real
 use fv_arrays_mod,     only: fv_grid_type, fv_grid_bounds_type, fv_nest_type, R_GRID

 use fms2_io_mod,       only : register_restart_field, open_file, close_file, &
                               read_restart, register_field, &
                               register_variable_attribute, file_exists, FmsNetcdfDomainFile_t
 use fv_io_mod,         only : fv_io_register_axis
 use axis_utils2_mod, only : frac_index

#ifdef ENABLE_ADA
 use ada_types_mod, only : model_data_type
 use ada_driver_fv_mod, only : init_fv_ada, fv_ada, ada_end
#endif

 implicit none
 private

 real(kind=R_GRID), parameter :: radius = cnst_radius

! version number of this module
! Include variable "version" to be written to log file.
#include<file_version.h>

 logical :: do_adiabatic_init

 public fv_ada_nudge, fv_ada_nudge_init, fv_ada_nudge_end, breed_slp_inline_ada
 public do_adiabatic_init

 !!! CLEANUP: Are these OK as module variables? They are not thread private.
 integer im     ! Data x-dimension
 integer jm     ! Data y-dimension
 integer km     ! Data z-dimension
 real, allocatable:: ak0(:), bk0(:)
 real, allocatable:: lat(:), lon(:)

 logical :: module_is_initialized = .false.
 logical :: master
 logical :: no_obs
 real :: deg2rad, rad2deg
 real :: time_nudge = 0.
 integer :: time_interval = 6*3600   ! dataset time interval (seconds)
 integer, parameter :: nfile_max = 125
 integer :: nfile
 integer :: last_year = -1 ! Last year used during read.  Negative value indicates not set.

 integer :: k_breed = 0
 integer :: k_trop = 0
 real    :: p_trop = 750.E2
 real    :: dps_min = 50.      ! maximum PS increment (pa; each step) due to inline breeding
 real    :: del2_cd = 0.16

 real,    allocatable:: s2c(:,:,:)
 integer, allocatable:: id1(:,:), id2(:,:), jdc(:,:)
 real, allocatable :: ps_dat(:,:,:)
 real(KIND=4), allocatable, dimension(:,:,:,:):: u_dat, v_dat, t_dat, q_dat
 real(KIND=4), allocatable, dimension(:,:,:):: gz3  ! work array
 real, allocatable:: gz0(:,:)

! Namelist variables:
 character(len=128):: file_names(nfile_max)
 character(len=128):: track_file_name
 integer :: nfile_total = 0       ! =5 for 1-day (if datasets are 6-hr apart)
 real    :: p_wvp = 100.E2        ! cutoff level for specific humidity nudging
 integer :: kord_data = 8

 real    :: mask_fac = 0.25        ! [0,1]  0: no mask;  1: full strength

 logical :: T_is_Tv  = .false.
 logical :: use_pt_inc  = .true.
 logical :: use_high_top = .false.
 logical :: add_bg_wind = .true.
 logical :: conserve_mom = .true.
 logical :: conserve_hgt = .true.
 logical :: tc_mask = .false.
 logical :: strong_mask = .false.
 logical :: ibtrack = .true.
 logical :: nudge_debug = .false.
 logical :: do_ps_bias  = .false.
 logical :: nudge_ps    = .false.
 logical :: nudge_t    = .false.
 logical :: nudge_q     = .false.
 logical :: nudge_winds = .true.
 logical :: nudge_virt  = .true.
 logical :: nudge_hght  = .true.
 logical :: time_varying = .true.
 logical :: print_end_breed = .true.
 logical :: print_end_nudge = .true.
 logical :: one_year_files = .false. ! Setting to true indicates the files to be read in have 1 year of time data
                                     ! Otherwise, assuming a single time per file (as originally written)
 logical :: ps_impact_uvt = .false.


! Nudging time-scales (seconds): note, however, the effective time-scale is 2X smaller (stronger) due
! to the use of the time-varying weighting factor
 real :: tau_ps     = 21600.       ! 1-day
 real :: tau_q      = 86400.       ! 1-day
 real :: tau_winds  = 21600.       !  6-hr
 real :: tau_t      = 86400.       !  6-hr
 real :: tau_virt   = 43200.
 real :: tau_hght   = 43200.

 real :: q_min      = 1.E-8

 integer :: jbeg, jend
 integer :: nf_uv = 0
 integer :: nf_ps = 0
 integer :: nf_t  = 2
 integer :: nf_ht = 2

! starting layer (top layer is sponge layer and is skipped)
 integer :: kstart = 2

! skip "kbot" layers
 integer :: kbot_winds = 0
 integer :: kbot_t     = 0
 integer :: kbot_q     = 1
 logical :: analysis_time

!-- Tropical cyclones  --------------------------------------------------------------------

! track dataset: 'INPUT/tropical_cyclones.txt'

  logical :: breed_vortex = .false.
  real :: grid_size     = 28.E3
  real :: tau_vt_slp    = 900.
  real :: tau_vt_wind   = 900.
  real :: tau_vt_rad    = 4.0

  real :: pt_lim =  0.2
  real ::  slp_env = 101010.    ! storm environment pressure (pa)
  real :: pre0_env = 100000.    ! critical storm environment pressure (pa) for size computation
  real, parameter:: tm_max = 315.
!------------------
  real:: r_lo = 2.0
  real:: r_hi = 5.0    ! try 4.0?
!------------------
  real::  r_fac = 1.2
  real :: r_min = 200.E3
  real :: r_inc =  25.E3
  real, parameter:: del_r = 50.E3
  real:: elapsed_time = 0.0
  real:: nudged_time = 1.E12 ! seconds
                             ! usage example: set to 43200. to do inline vortex breeding
                             ! for only the first 12 hours
                             ! In addition, specify only 3 analysis files (12 hours)
  integer:: year_track_data
  integer, parameter:: max_storm = 140     ! max # of storms to process
  integer, parameter::  nobs_max = 125     ! Max # of observations per storm

  integer :: nstorms = 0
  integer :: nobs_tc(max_storm)
  integer :: min_nobs = 16
  real :: min_mslp = 1000.E2
  real(KIND=4)::     x_obs(nobs_max,max_storm)           ! longitude in degrees
  real(KIND=4)::     y_obs(nobs_max,max_storm)           ! latitude in degrees
  real(KIND=4)::  wind_obs(nobs_max,max_storm)           ! observed 10-m wind speed (m/s)
  real(KIND=4)::  mslp_obs(nobs_max,max_storm)           ! observed SLP in mb
  real(KIND=4)::  mslp_out(nobs_max,max_storm)           ! outer ring SLP in mb
  real(KIND=4)::   rad_out(nobs_max,max_storm)           ! outer ring radius in meters
  real(KIND=4)::   time_tc(nobs_max,max_storm)           ! start time of the track
!------------------------------------------------------------------------------------------
  integer :: id_ht_err
  real :: mslp_obs_arg

  integer, dimension(2) :: atm_layout ! snz
  integer :: filt_halo0 ! snz
  integer :: filt_halo  ! snz
  integer :: isd_filt, ied_filt, jsd_filt, jed_filt ! snz

!------snz add diag variables for ada increments
  integer :: id_u_ncep, id_v_ncep, id_t_ncep, id_q_ncep, id_ps_ncep ! snz
  integer :: id_u_damb, id_v_damb, id_t_damb, id_q_damb, id_ps_damb ! snz
  integer :: id_u_adj, id_v_adj, id_t_adj, id_q_adj, id_ps_adj ! snz
  integer :: id_u_a, id_v_a, id_t_a, id_q_a, id_ps_a ! snz
  integer :: id_u_da, id_v_da, id_t_da, id_q_da, id_ps_da ! snz

  type(FmsNetcdfDomainFile_t) :: ada_driver_restart ! snz
  character(len=*), parameter :: restart_file="INPUT/ada_driver.res.nc" ! snz
  character(len=8), dimension(4) :: dim_names_4d

#ifdef ENABLE_ADA ! snz
  type(model_data_type) :: Atm_var
  type(domain2d), private, save :: filt_domain
  real, allocatable :: weight(:,:,:)
  real :: weight_sum, alat(361)
  integer :: i_sm, j_sm, jlat
#endif

  !!! CLEANUP Module pointers

 namelist /fv_ada_nudge_nml/T_is_Tv, nudge_ps, nudge_virt, nudge_hght, nudge_q, nudge_t, nudge_winds,  &
                          do_ps_bias, tau_ps, tau_winds, tau_t, tau_q, tau_virt, tau_hght,  kstart, kbot_winds, &
                          k_breed, k_trop, p_trop, dps_min, kord_data, tc_mask, nudge_debug, nf_ps, nf_t, nf_ht,  &
                          nf_uv, breed_vortex, tau_vt_wind, tau_vt_slp, strong_mask, mask_fac, del2_cd,   &
                          kbot_t, kbot_q, p_wvp, time_varying, time_interval, use_pt_inc, pt_lim,  &
                          tau_vt_rad, r_lo, r_hi, use_high_top, add_bg_wind, conserve_mom, conserve_hgt,  &
                          min_nobs, min_mslp, nudged_time, r_fac, r_min, r_inc, ibtrack, track_file_name, file_names, &
                          one_year_files, &
                          atm_layout, filt_halo0, ps_impact_uvt

 contains


  subroutine fv_ada_nudge ( Time, dt, npx, npy, npz, ps_dt, u_dt, v_dt, t_dt, q_dt, zvir, &
                            ak, bk, ts, ps, delp, ua, va, pt, nwat, q, phis, gridstruct, &
                            bd, domain )

  type(time_type), intent(in):: Time
  integer,         intent(IN):: npx, npy
  integer,         intent(in):: npz           ! vertical dimension
  integer,         intent(in):: nwat
  real,            intent(in):: dt
  real,            intent(in):: zvir
  type(domain2d), intent(INOUT), target :: domain
  type(fv_grid_bounds_type), intent(IN) :: bd
  real, intent(in   ), dimension(npz+1):: ak, bk
  real, intent(in   ), dimension(bd%isd:bd%ied,bd%jsd:bd%jed    ):: phis
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: pt, ua, va, delp
! pt as input is true tempeature
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz,nwat):: q
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed):: ps
! Accumulated tendencies
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: u_dt, v_dt
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: t_dt
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: q_dt
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: ps_dt, ts

  type(fv_grid_type), intent(INOUT), target :: gridstruct
! local:
  real:: hght2(bd%is:bd%ie,bd%js:bd%je)         ! height at specified model interface level
  real:: m_err(bd%is:bd%ie,bd%js:bd%je)         ! height error at specified model interface level
  real:: slp_n(bd%is:bd%ie,bd%js:bd%je)         ! "Observed" SLP
  real:: slp_m(bd%is:bd%ie,bd%js:bd%je)         ! "model" SLP
  real::   mask(bd%is:bd%ie,bd%js:bd%je)
  real::     tv(bd%is:bd%ie,bd%js:bd%je)
  real:: gz_int(bd%is:bd%ie,bd%js:bd%je), gz(bd%is:bd%ie,npz+1), peln(bd%is:bd%ie,npz+1), pk(bd%is:bd%ie,npz+1)
  real:: pe1(bd%is:bd%ie)
  real:: pkz, ptmp
  real, allocatable :: ps_obs(:,:)
  real, allocatable, dimension(:,:,:):: u_obs, v_obs, t_obs, q_obs
  real, allocatable, dimension(:,:,:):: du_obs, dv_obs
  integer :: seconds, days
  integer :: i,j,k, iq, kht
  real :: factor, rms, bias, co
  real :: q_rat, pst, pt0, pkz0
  real :: dbk, rdt, press(npz), profile(npz), prof_t(npz), prof_q(npz), du, dv
  logical used
  real :: diff_t, dt_const

  integer :: is,  ie,  js,  je
  integer :: isd, ied, jsd, jed

  real(kind=R_GRID), pointer, dimension(:,:,:) :: agrid
  real, pointer, dimension(:,:)   :: rarea, area

  real, pointer, dimension(:,:) :: sina_u, sina_v
  real, pointer, dimension(:,:,:) :: sin_sg

  real, pointer, dimension(:,:) :: dx, dy, rdxc, rdyc

  logical, pointer :: nested, sw_corner, se_corner, nw_corner, ne_corner

  if ( .not. module_is_initialized ) then
        call mpp_error(FATAL,'==> Error from fv_ada_nudge: module not initialized')
  endif

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je
  isd = bd%isd
  ied = bd%ied
  jsd = bd%jsd
  jed = bd%jed

  agrid => gridstruct%agrid_64
   area => gridstruct%area
  rarea => gridstruct%rarea

  sina_u => gridstruct%sina_u
  sina_v => gridstruct%sina_v
  sin_sg => gridstruct%sin_sg

  dx     => gridstruct%dx
  dy     => gridstruct%dy
  rdxc   => gridstruct%rdxc
  rdyc   => gridstruct%rdyc

  nested => gridstruct%nested
  sw_corner => gridstruct%sw_corner
  se_corner => gridstruct%se_corner
  nw_corner => gridstruct%nw_corner
  ne_corner => gridstruct%ne_corner

  if ( no_obs ) then
#ifndef DYCORE_SOLO
       forecast_mode = .true.
#endif
       return
  endif

  call get_time (time, seconds, days)

  do j=js,je
     do i=is,ie
        mask(i,j) = 1.
     enddo
  enddo
  if ( tc_mask )  call get_tc_mask(time, mask, bd, agrid)

! The following profile is suitable only for ada purposes; if the analysis has a good representation
! of the strat-meso-sphere the profile for upper layers should be changed.

  profile(:) = 1.

!$omp parallel do default(shared)
  do k=1,npz
     press(k) = 0.5*(ak(k) + ak(k+1)) + 0.5*(bk(k)+bk(k+1))*1.E5
     if ( press(k) < 30.E2 ) then
          profile(k) =  max(0.01, press(k)/30.E2)
     endif
  enddo
  profile(1) = 0.

! Thermodynamics:
  prof_t(:) = 1.
!$omp parallel do default(shared)
  do k=1,npz
     if ( press(k) < 30.E2 ) then
          prof_t(k) =  max(0.01, press(k)/30.E2)
     endif
  enddo
  prof_t(1) = 0.

! Water vapor:
  prof_q(:) = 1.
!$omp parallel do default(shared)
  do k=1,npz
     if ( press(k) < 300.E2 ) then
          prof_q(k) =  max(0., press(k)/300.E2)
     endif
  enddo
  prof_q(1) = 0.

! Height
  if ( k_trop == 0 ) then
       k_trop = 2
       do k=2,npz-1
          ptmp = ak(k+1) + bk(k+1)*1.E5
          if ( ptmp > p_trop ) then
               k_trop = k
               exit
          endif
       enddo
  endif

  if ( time_varying ) then
       factor = 1. + cos(real(mod(seconds,time_interval))/real(time_interval)*2.*pi)
       factor = max(1.e-5, factor)
  else
       factor = 1.
  endif

  if ( do_adiabatic_init ) factor = 2.*factor

  allocate (ps_obs(is:ie,js:je) )
  allocate ( t_obs(is:ie,js:je,npz) )
  allocate ( q_obs(is:ie,js:je,npz) )

  if ( nudge_winds ) then
       allocate (u_obs(is:ie,js:je,npz) )
       allocate (v_obs(is:ie,js:je,npz) )
  endif


  call get_obs(Time, dt, zvir, ak, bk, ps, ts, ps_obs, delp, pt, nwat, q, u_obs, v_obs, t_obs, q_obs,   &
               phis, gz_int, ua, va, u_dt, v_dt, npx, npy, npz, factor, mask, bd, gridstruct, domain)
! *t_obs* is virtual temperature
#ifdef ENABLE_ADA ! snz

!  call get_time (time, seconds, days)

  if (mod(seconds, 21600) == 0) then

     Atm_var%u(is:ie,js:je,:) = ua(is:ie,js:je,:)
     Atm_var%v(is:ie,js:je,:) = va(is:ie,js:je,:)
     Atm_var%t(is:ie,js:je,:) = pt(is:ie,js:je,:)
     Atm_var%q(is:ie,js:je,:) = q(is:ie,js:je,:,1)
     Atm_var%dp(is:ie,js:je,:) = delp(is:ie,js:je,:)
     Atm_var%ps(is:ie,js:je) = ps(is:ie,js:je)
     Atm_var%phis(is:ie,js:je) = phis(is:ie,js:je)

     call mpp_update_domains(Atm_var%u(:,:,:), filt_domain, complete=.false.)
     call mpp_update_domains(Atm_var%v(:,:,:), filt_domain, complete=.false.)
     call mpp_update_domains(Atm_var%t(:,:,:), filt_domain, complete=.false.)
     call mpp_update_domains(Atm_var%q(:,:,:), filt_domain, complete=.false.)
     call mpp_update_domains(Atm_var%dp(:,:,:), filt_domain, complete=.true.)
     call mpp_update_domains(Atm_var%ps(:,:), filt_domain, complete=.false.)
     call mpp_update_domains(Atm_var%phis(:,:), filt_domain, complete=.true.)

     ! handle the lower-left corner
     if (is == 1 .and. js == 1) then
       do k = 1, npz
       do j = js-filt_halo, js-1
       do i = is-filt_halo, is-1
         Atm_var%u(i,j,k) = Atm_var%u(is-i,js-j,k)
         Atm_var%v(i,j,k) = Atm_var%v(is-i,js-j,k)
         Atm_var%t(i,j,k) = Atm_var%t(is-i,js-j,k)
         Atm_var%q(i,j,k) = Atm_var%q(is-i,js-j,k)
         Atm_var%dp(i,j,k) = Atm_var%dp(is-i,js-j,k)
       end do
       end do
       end do
       do j = js-filt_halo, js-1
       do i = is-filt_halo, is-1
         Atm_var%ps(i,j) = Atm_var%ps(is-i,js-j)
         Atm_var%phis(i,j) = Atm_var%phis(is-i,js-j)
       end do
       end do
     end if
     ! handle the lower-right corner
     if (ie == npx-1 .and. js == 1) then
       do k = 1, npz
       do j = js-filt_halo, js-1
       do i = ie+1, ie+filt_halo
         Atm_var%u(i,j,k) = Atm_var%u(ie-i+ie+1,js-j,k)
         Atm_var%v(i,j,k) = Atm_var%v(ie-i+ie+1,js-j,k)
         Atm_var%t(i,j,k) = Atm_var%t(ie-i+ie+1,js-j,k)
         Atm_var%q(i,j,k) = Atm_var%q(ie-i+ie+1,js-j,k)
         Atm_var%dp(i,j,k) = Atm_var%dp(ie-i+ie+1,js-j,k)
       end do
       end do
       end do
       do j = js-filt_halo, js-1
       do i = ie+1, ie+filt_halo
         Atm_var%ps(i,j) = Atm_var%ps(ie-i+ie+1,js-j)
         Atm_var%phis(i,j) = Atm_var%phis(ie-i+ie+1,js-j)
       end do
       end do
     end if
     ! handle the upper-right corner
     if (ie == npx-1 .and. je == npy-1) then
       do k = 1, npz
       do j = je+1, je+filt_halo
       do i = ie+1, ie+filt_halo
         Atm_var%u(i,j,k) = Atm_var%u(ie-i+ie+1,je-j+je+1,k)
         Atm_var%v(i,j,k) = Atm_var%v(ie-i+ie+1,je-j+je+1,k)
         Atm_var%t(i,j,k) = Atm_var%t(ie-i+ie+1,je-j+je+1,k)
         Atm_var%q(i,j,k) = Atm_var%q(ie-i+ie+1,je-j+je+1,k)
         Atm_var%dp(i,j,k) = Atm_var%dp(ie-i+ie+1,je-j+je+1,k)
       end do
       end do
       end do
       do j = je+1, je+filt_halo
       do i = ie+1, ie+filt_halo
         Atm_var%ps(i,j) = Atm_var%ps(ie-i+ie+1,je-j+je+1)
         Atm_var%phis(i,j) = Atm_var%phis(ie-i+ie+1,je-j+je+1)
       end do
       end do
     end if
     ! end of handling corners

     if (filt_halo0 > 0) then ! for smooth

     do k = 1, npz
     do j = js, je
     do i = is, ie
       jlat = floor(frac_index(agrid(i,j,2)*rad2deg, alat(:)))
       Atm_var%u_a(i,j,k) = 0.0
       Atm_var%v_a(i,j,k) = 0.0
       Atm_var%t_a(i,j,k) = 0.0
       Atm_var%q_a(i,j,k) = 0.0
       do j_sm = j-filt_halo,j+filt_halo
       do i_sm = i-filt_halo,i+filt_halo
         Atm_var%u_a(i,j,k) = Atm_var%u_a(i,j,k)+weight(i_sm-i,j_sm-j,jlat)*Atm_var%u(i_sm,j_sm,k)
         Atm_var%v_a(i,j,k) = Atm_var%v_a(i,j,k)+weight(i_sm-i,j_sm-j,jlat)*Atm_var%v(i_sm,j_sm,k)
         Atm_var%t_a(i,j,k) = Atm_var%t_a(i,j,k)+weight(i_sm-i,j_sm-j,jlat)*Atm_var%t(i_sm,j_sm,k)
         Atm_var%q_a(i,j,k) = Atm_var%q_a(i,j,k)+weight(i_sm-i,j_sm-j,jlat)*Atm_var%q(i_sm,j_sm,k)
       end do
       end do
     end do
     end do
     end do
     do j = js, je
     do i = is, ie
       jlat = floor(frac_index(agrid(i,j,2)*rad2deg, alat(:)))
       Atm_var%ps_a(i,j) = 0.0
       do j_sm = j-filt_halo,j+filt_halo
       do i_sm = i-filt_halo,i+filt_halo
         Atm_var%ps_a(i,j) = Atm_var%ps_a(i,j)+weight(i_sm-i,j_sm-j,jlat)*Atm_var%ps(i_sm,j_sm)
       end do
       end do
     end do
     end do
     ua(is:ie,js:je,:)  = Atm_var%u_a(is:ie,js:je,:)
     va(is:ie,js:je,:)  = Atm_var%v_a(is:ie,js:je,:)
     pt(is:ie,js:je,:)  = Atm_var%t_a(is:ie,js:je,:)
     q(is:ie,js:je,:,1) = Atm_var%q_a(is:ie,js:je,:)
     ps(is:ie,js:je)    = Atm_var%ps_a(is:ie,js:je)

     call mpp_update_domains(ua(:,:,:), domain, complete=.false.)
     call mpp_update_domains(va(:,:,:), domain, complete=.false.)
     call mpp_update_domains(pt(:,:,:), domain, complete=.false.)
     call mpp_update_domains(q(:,:,:,1), domain, complete=.true.)
     call mpp_update_domains(ps(:,:), domain, complete=.true.)

     Atm_var%u_a(is:ie,js:je,:)  = Atm_var%u(is:ie,js:je,:) - Atm_var%u_a(is:ie,js:je,:)
     Atm_var%v_a(is:ie,js:je,:)  = Atm_var%v(is:ie,js:je,:) - Atm_var%v_a(is:ie,js:je,:)
     Atm_var%t_a(is:ie,js:je,:)  = Atm_var%t(is:ie,js:je,:) - Atm_var%t_a(is:ie,js:je,:)
     Atm_var%q_a(is:ie,js:je,:)  = Atm_var%q(is:ie,js:je,:) - Atm_var%q_a(is:ie,js:je,:)
     Atm_var%ps_a(is:ie,js:je)   = Atm_var%ps(is:ie,js:je) - Atm_var%ps_a(is:ie,js:je)

     call mpp_update_domains(Atm_var%u_a(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%v_a(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%t_a(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%q_a(:,:,:), domain, complete=.true.)
     call mpp_update_domains(Atm_var%ps_a(:,:), domain, complete=.true.)

     else ! no smooth

     Atm_var%u_a(is:ie,js:je,:)  = 0.0
     Atm_var%v_a(is:ie,js:je,:)  = 0.0
     Atm_var%t_a(is:ie,js:je,:)  = 0.0
     Atm_var%q_a(is:ie,js:je,:)  = 0.0
     Atm_var%ps_a(is:ie,js:je)   = 0.0

     end if ! for smooth or not

     if ( id_u_ncep > 0 ) used=send_data(id_u_ncep, u_obs(is:ie,js:je,:), Time)
     if ( id_v_ncep > 0 ) used=send_data(id_v_ncep, v_obs(is:ie,js:je,:), Time)
     if ( id_t_ncep > 0 ) used=send_data(id_t_ncep, t_obs(is:ie,js:je,:), Time)
     if ( id_q_ncep > 0 ) used=send_data(id_q_ncep, q_obs(is:ie,js:je,:), Time)
     if ( id_ps_ncep > 0 ) used=send_data(id_ps_ncep, ps_obs(is:ie,js:je), Time)

     if ( id_u_damb > 0 ) used=send_data(id_u_damb, ua(is:ie,js:je,:), Time)
     if ( id_v_damb > 0 ) used=send_data(id_v_damb, va(is:ie,js:je,:), Time)
     if ( id_t_damb > 0 ) used=send_data(id_t_damb, pt(is:ie,js:je,:), Time)
     if ( id_q_damb > 0 ) used=send_data(id_q_damb, q(is:ie,js:je,:,1), Time)
     if ( id_ps_damb > 0 ) used=send_data(id_ps_damb, ps(is:ie,js:je), Time)

     if ( id_u_a > 0 ) used=send_data(id_u_a, Atm_var%u_a(is:ie,js:je,:), Time)
     if ( id_v_a > 0 ) used=send_data(id_v_a, Atm_var%v_a(is:ie,js:je,:), Time)
     if ( id_t_a > 0 ) used=send_data(id_t_a, Atm_var%t_a(is:ie,js:je,:), Time)
     if ( id_q_a > 0 ) used=send_data(id_q_a, Atm_var%q_a(is:ie,js:je,:), Time)
     if ( id_ps_a > 0 ) used=send_data(id_ps_a, Atm_var%ps_a(is:ie,js:je), Time)

     call fv_ada(time, ak, bk, Atm_var)

     Atm_var%u_adj(is:ie,js:je,1:npz) = Atm_var%u(is:ie,js:je,1:npz) - ua(is:ie,js:je,1:npz)
     Atm_var%v_adj(is:ie,js:je,1:npz) = Atm_var%v(is:ie,js:je,1:npz) - va(is:ie,js:je,1:npz)
     Atm_var%t_adj(is:ie,js:je,1:npz) = Atm_var%t(is:ie,js:je,1:npz) - pt(is:ie,js:je,1:npz)
     Atm_var%q_adj(is:ie,js:je,1:npz) = Atm_var%q(is:ie,js:je,1:npz) - q(is:ie,js:je,1:npz,1)
     Atm_var%ps_adj(is:ie,js:je) = Atm_var%ps(is:ie,js:je) - ps(is:ie,js:je)

     call mpp_update_domains(Atm_var%u_adj(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%v_adj(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%t_adj(:,:,:), domain, complete=.false.)
     call mpp_update_domains(Atm_var%q_adj(:,:,:), domain, complete=.true.)
     call mpp_update_domains(Atm_var%ps_adj(:,:), domain, complete=.true.)

     if ( id_u_adj > 0 ) used=send_data(id_u_adj, Atm_var%u_adj(is:ie,js:je,:), Time)
     if ( id_v_adj > 0 ) used=send_data(id_v_adj, Atm_var%v_adj(is:ie,js:je,:), Time)
     if ( id_t_adj > 0 ) used=send_data(id_t_adj, Atm_var%t_adj(is:ie,js:je,:), Time)
     if ( id_q_adj > 0 ) used=send_data(id_q_adj, Atm_var%q_adj(is:ie,js:je,:), Time)
     if ( id_ps_adj > 0 ) used=send_data(id_ps_adj, Atm_var%ps_adj(is:ie,js:je), Time)

     ua(is:ie,js:je,:) = ua(is:ie,js:je,:) + Atm_var%u_a(is:ie,js:je,:)
     va(is:ie,js:je,:) = va(is:ie,js:je,:) + Atm_var%v_a(is:ie,js:je,:)
     pt(is:ie,js:je,:) = pt(is:ie,js:je,:) + Atm_var%t_a(is:ie,js:je,:)

  end if ! for 6-hour reanalysis data

  diff_t = 18.0-mod(seconds,21600)/1200.0
  dt_const = 1./171.*diff_t

  ! update delp and ps
  do j=js,je
  do i=is,ie
    ps(i,j) = ak(1)
  enddo
  enddo

  do k = 1, npz
    dbk = (bk(k+1) - bk(k))*dt_const
    do j = js, je
    do i = is, ie
      delp(i,j,k) = delp(i,j,k) + dbk*Atm_var%ps_adj(i,j)
          ps(i,j) = delp(i,j,k) + ps(i,j)
    end do
    end do
  end do

  ! if ps_inpact_uvt, then update u, v, pt
  if (ps_impact_uvt) then
    ua(is:ie,js:je,:) = ua(is:ie,js:je,:) + Atm_var%u_adj(is:ie,js:je,:)*dt_const
    va(is:ie,js:je,:) = va(is:ie,js:je,:) + Atm_var%v_adj(is:ie,js:je,:)*dt_const
    pt(is:ie,js:je,:) = pt(is:ie,js:je,:) + Atm_var%t_adj(is:ie,js:je,:)*dt_const
    call mpp_update_domains(ua(:,:,:), domain, complete=.false.)
    call mpp_update_domains(va(:,:,:), domain, complete=.false.)
    call mpp_update_domains(pt(:,:,:), domain, complete=.true.)
  end if


#endif ! snz

  if ( no_obs ) then
       deallocate (ps_obs)
       deallocate (t_obs)
       deallocate (q_obs)
       if ( nudge_winds ) then
            deallocate (u_obs)
            deallocate (v_obs)
       endif
#ifndef DYCORE_SOLO
       forecast_mode = .true.
#endif
       return
   endif

  if( analysis_time ) then
!-------------------------------------------
! Compute RMSE, bias, and correlation of SLP
!-------------------------------------------
      do j=js,je
         do i=is,ie
            tv(i,j) = pt(i,j,npz)*(1.+zvir*q(i,j,npz,1))
         enddo
      enddo
      call compute_slp(is, ie, js, je, tv, ps(is:ie,js:je), phis(is:ie,js:je), slp_m)
      call compute_slp(is, ie, js, je, t_obs(is:ie,js:je,npz:npz), ps_obs, gz0, slp_n)

      if ( nudge_debug ) then
           call prt_maxmin('PS_o', ps_obs, is, ie, js, je, 0, 1, 0.01)
           ptmp = 0.01*g0_sum(ps_obs, is, ie, js, je, 1, .false., isd, ied, jsd, jed, area)
           if(master) write(*,*) 'Mean PS_o=', ptmp
           call prt_maxmin('SLP_m', slp_m, is, ie, js, je, 0, 1, 0.01)
           call prt_maxmin('SLP_o', slp_n, is, ie, js, je, 0, 1, 0.01)
      endif

!$omp parallel do default(shared)
      do j=js,je
         do i=is,ie
            if ( phis(i,j)/grav > 500. ) then
! Exclude high terrains region for RMS and bias computation
                 m_err(i,j) = 0.
            else
                 m_err(i,j) = mask(i,j)*(slp_m(i,j) - slp_n(i,j))
            endif
         enddo
      enddo

      call rmse_bias(m_err, rms, bias, bd, area)
      call corr(slp_m, slp_n, co, bd, area)

      if(master) write(*,*) 'SLP (mb): RMS=', 0.01*rms, ' Bias=', 0.01*bias
      if(master) write(*,*) 'SLP correlation=',co
  endif

  if ( nudge_winds ) then

       allocate (du_obs(is:ie,js:je,npz) )
       allocate (dv_obs(is:ie,js:je,npz) )

! Compute tendencies:
     rdt = 1. / (tau_winds/factor + dt)
!$omp parallel do default(shared)
     do k=kstart, npz - kbot_winds
        do j=js,je
           do i=is,ie
              du_obs(i,j,k) = profile(k)*(u_obs(i,j,k)-ua(i,j,k))*rdt
              dv_obs(i,j,k) = profile(k)*(v_obs(i,j,k)-va(i,j,k))*rdt
           enddo
        enddo
     enddo

     if ( nf_uv>0 ) call del2_uv(du_obs, dv_obs, del2_cd, npz, nf_uv, bd, npx, npy, gridstruct, domain)

!$omp parallel do default(shared)
     do k=kstart, npz - kbot_winds
        do j=js,je
           do i=is,ie
! Apply TC mask
              du_obs(i,j,k) = du_obs(i,j,k) * mask(i,j)
              dv_obs(i,j,k) = dv_obs(i,j,k) * mask(i,j)
!
              u_dt(i,j,k) = u_dt(i,j,k) + du_obs(i,j,k)
              v_dt(i,j,k) = v_dt(i,j,k) + dv_obs(i,j,k)
                ua(i,j,k) =   ua(i,j,k) + du_obs(i,j,k)*dt
                va(i,j,k) =   va(i,j,k) + dv_obs(i,j,k)*dt
           enddo
        enddo
     enddo

     deallocate (du_obs)
     deallocate (dv_obs)

  endif

  if ( nudge_virt ) then
     if(nudge_debug) call prt_maxmin('T_obs', t_obs, is, ie, js, je, 0, npz, 1.)
  endif

!---------------------- temp -----------
  if ( nudge_virt .and. nudge_hght ) then
       tau_virt = max(tau_hght, tau_virt)
       kht = k_trop
  else
       kht = npz-kbot_t
  endif
!---------------------- temp -----------

  t_dt(:,:,:) = 0.

  if ( nudge_hght ) then

        rdt = dt / (tau_hght/factor + dt)

!$omp parallel do default(shared) private(pe1, peln, pk, gz)
        do j=js,je

           do i=is,ie
              pe1(i) = ak(1)
              peln(i,1) = log(pe1(i))
                pk(i,1) = pe1(i)**kappa
           enddo
           do k=2, npz+1
              do i=is,ie
                    pe1(i) = pe1(i) + delp(i,j,k-1)
                 peln(i,k) = log(pe1(i))
                   pk(i,k) = pe1(i)**kappa
              enddo
           enddo

           do i=is,ie
              gz(i,npz+1) = phis(i,j)
           enddo
           do i=is,ie
              do k=npz, k_trop+1, -1
                 gz(i,k) = gz(i,k+1) + rdgas*pt(i,j,k)*(1.+zvir*q(i,j,k,1))*(peln(i,k+1)-peln(i,k))
              enddo
           enddo

           do i=is,ie
              hght2(i,j) =  gz(i,k_trop+1)
if ( use_pt_inc ) then
              m_err(i,j) = (gz_int(i,j)-hght2(i,j))/(cp_air*(pk(i,npz+1)-pk(i,k_trop+1)))
              m_err(i,j) = m_err(i,j)*max( 0., 1.-abs(gz0(i,j)-phis(i,j))/(grav*1000.) )
              m_err(i,j) = sign( min(pt_lim, abs(m_err(i,j))), m_err(i,j) )
else
! Virtual Temperature increment:
              m_err(i,j) = (gz_int(i,j)-hght2(i,j))/(rdgas*(peln(i,npz+1)-peln(i,k_trop+1)))
              m_err(i,j) = m_err(i,j)*max( 0., 1.-abs(gz0(i,j)-phis(i,j))/(grav*500.) )
              m_err(i,j) = sign( min(5.0, abs(m_err(i,j))), m_err(i,j) )
endif
           enddo

        enddo   ! j-loop

! Filter:
        if ( nf_ht > 0 ) call del2_scalar(m_err, del2_cd, 1, nf_ht, bd, npx, npy, gridstruct, domain)

        if ( use_pt_inc ) then
             pkz0 = (1.0E5)**kappa
        else
             pkz0 = 1.
        endif
        call prt_maxmin('T_inc (deg)', m_err, is, ie, js, je, 0, 1, pkz0)

!$omp parallel do default(shared) private(pe1, peln, pk, pt0, pkz)
        do j=js,je

! if ( use_pt_inc ) then
           do i=is,ie
              pe1(i) = ak(1)
              peln(i,1) = log(pe1(i))
                pk(i,1) = pe1(i)**kappa
           enddo
           do k=2, npz+1
              do i=is,ie
                    pe1(i) = pe1(i) + delp(i,j,k-1)
                 peln(i,k) = log(pe1(i))
                   pk(i,k) = pe1(i)**kappa
              enddo
           enddo
! endif
           do i=is,ie
              pt0 = rdt*mask(i,j)*m_err(i,j)
              do k=k_trop+1,npz
if ( use_pt_inc ) then
! Add constant "virtual potential temperature" increment to correct height at p_interface
!------------------------------------------------------------------------------------------
                 pkz = (pk(i,k+1)-pk(i,k))/(kappa*(peln(i,k+1)-peln(i,k)))
                 pt(i,j,k) = pt(i,j,k) + pkz*pt0 / (1.+zvir*q(i,j,k,1))
!------------------------------------------------------------------------------------------
else
! Add constant "virtual temperature" increment
                 pt(i,j,k) = pt(i,j,k) + pt0 / (1.+zvir*q(i,j,k,1))
endif
              enddo
              m_err(i,j) = (gz_int(i,j)-hght2(i,j)) / (rdgas*(peln(i,npz+1)-peln(i,k_trop+1)))
           enddo
        enddo   ! j-loop
        if ( (.not.do_adiabatic_init) .and. id_ht_err>0 ) used=send_data(id_ht_err, m_err, Time)

!-----------------------
! Compute RMSE of height
!-----------------------
        if( analysis_time ) then
!$omp parallel do default(shared)
            do j=js,je
               do i=is,ie
                  m_err(i,j) = (hght2(i,j) - gz_int(i,j)) / grav
               enddo
            enddo
            call corr(hght2, gz_int, co, bd, area)
            call prt_maxmin('H_int_obs', gz_int, is, ie, js, je, 0, 1, 1./grav)
            call prt_maxmin('H_int_err',  m_err, is, ie, js, je, 0, 1, 1.     )
            call rmse_bias(m_err, rms, bias, bd, area)
            if(master) write(*,*) 'HGHT: RMSE (m)=', rms, ' Bias (m)=', bias
            if(master) write(*,*) 'HGHT: correlation=', co
        endif
  endif

  if ( nudge_virt ) then
        rdt = 1./(tau_virt/factor + dt)
!$omp parallel do default(shared)
     do k=kstart, kht
        do j=js,je
           do i=is,ie
              t_dt(i,j,k) = prof_t(k)*(t_obs(i,j,k)/(1.+zvir*q(i,j,k,1))-pt(i,j,k))*rdt
           enddo
        enddo
     enddo
  endif


  if ( nudge_virt ) then
! Filter t_dt here:
       if ( nf_t>0 ) call del2_scalar(t_dt, del2_cd, npz, nf_t, bd, npx, npy, gridstruct, domain)

!$omp parallel do default(shared)
       do k=kstart, kht
          do j=js,je
             do i=is,ie
                pt(i,j,k) = pt(i,j,k) + t_dt(i,j,k)*dt*mask(i,j)
            enddo
         enddo
       enddo
  endif

  q_dt(:,:,:) = 0.
  if ( nudge_q ) then
       rdt = 1./(tau_q/factor + dt)
!$omp parallel do default(shared)
     do k=kstart, npz - kbot_q
        if ( press(k) > p_wvp ) then
            do iq=2,nwat
               do j=js,je
                  do i=is,ie
                     q(i,j,k,iq) = q(i,j,k,iq)*delp(i,j,k)
                  enddo
               enddo
            enddo
! Specific humidity:
            do j=js,je
               do i=is,ie
                  delp(i,j,k) = delp(i,j,k)*(1.-q(i,j,k,1))
                  q_dt(i,j,k) = prof_q(k)*(max(q_min,q_obs(i,j,k))-q(i,j,k,1))*rdt*mask(i,j)
                   q(i,j,k,1) = q(i,j,k,1) + q_dt(i,j,k)*dt
                  delp(i,j,k) = delp(i,j,k)/(1.-q(i,j,k,1))
               enddo
            enddo
            do iq=2,nwat
               do j=js,je
                  do i=is,ie
                     q(i,j,k,iq) = q(i,j,k,iq)/delp(i,j,k)
                  enddo
               enddo
            enddo
        endif
     enddo
  endif

  ps_dt(:,:) = 0.

  deallocate ( t_obs )
  deallocate ( q_obs )
  deallocate ( ps_obs )

  if ( breed_vortex )   &
  call breed_srf_winds(Time, dt, npz, u_obs, v_obs, ak, bk, ps, phis, delp, ua, va, u_dt, v_dt, pt, q, nwat, zvir, bd, gridstruct)

  if ( nudge_winds ) then
     deallocate ( u_obs )
     deallocate ( v_obs )
  endif

  nullify(agrid)
  nullify(area)
  nullify(rarea)

  nullify(sina_u)
  nullify(sina_v)
  nullify(sin_sg)

  nullify(dx)
  nullify(dy)
  nullify(rdxc)
  nullify(rdyc)

  nullify(nested)
  nullify(sw_corner)
  nullify(se_corner)
  nullify(nw_corner)
  nullify(ne_corner)

 end  subroutine fv_ada_nudge


 subroutine ps_nudging(dt, factor, npz, ak, bk, ps_obs, mask, tm, ps, phis, delp, ua, va, pt, nwat, q, bd, npx, npy, gridstruct, domain)
! Input
      real, intent(in):: dt, factor
      integer, intent(in):: npz, nwat, npx, npy
      real, intent(in), dimension(npz+1):: ak, bk
      type(fv_grid_bounds_type), intent(IN) :: bd
      real, intent(in):: phis(bd%isd:bd%ied,bd%jsd:bd%jed)
      real, intent(in), dimension(bd%is:bd%ie,bd%js:bd%je):: ps_obs, mask, tm
      type(fv_grid_type), intent(IN), target :: gridstruct
      type(domain2d), intent(INOUT) :: domain
! Input/Output
      real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed):: ps
      real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp, pt, ua, va
      real, intent(inout):: q(bd%isd:bd%ied,bd%jsd:bd%jed,npz,nwat)
! local
      real, dimension(bd%is:bd%ie,bd%js:bd%je):: ps_dt
      integer, parameter:: kmax = 100
      real:: pn0(kmax+1), pk0(kmax+1)
      real, dimension(bd%is:bd%ie,npz+1):: pe2, peln
      real:: pst, dbk, pt0, rdt, bias
      integer i, j, k, iq

      real, pointer, dimension(:,:) :: area

      integer :: is,  ie,  js,  je

      is  = bd%is
      ie  = bd%ie
      js  = bd%js
      je  = bd%je

      area => gridstruct%area

! Adjust interpolated ps to model terrain
    if ( kmax < km ) call mpp_error(FATAL,'==> KMAX must be larger than km')

    do j=js,je
       do 666 i=is,ie
       do k=1, km+1
          pk0(k) = (ak0(k) + bk0(k)*ps_obs(i,j))**kappa
       enddo
      if( phis(i,j)>gz0(i,j) ) then
          do k=km,1,-1
             if( phis(i,j)<gz3(i,j,k) .and. phis(i,j) >= gz3(i,j,k+1) ) then
                 pst = pk0(k) + (pk0(k+1)-pk0(k))*(gz3(i,j,k)-phis(i,j))/(gz3(i,j,k)-gz3(i,j,k+1))
                 go to 666
             endif
          enddo
      else
          pn0(km  ) = log(ak0(km) + bk0(km)*ps_obs(i,j))
          pn0(km+1) = log(ps_obs(i,j))
! Extrapolation into the ground using only the lowest layer potential temp
           pt0 = tm(i,j)/(pk0(km+1)-pk0(km))*(kappa*(pn0(km+1)-pn0(km)))
           pst = pk0(km+1) + (gz0(i,j)-phis(i,j))/(cp_air*pt0)
      endif
      ps_dt(i,j) = pst**(1./kappa) - ps(i,j)
666   continue ! i-loop
      enddo   ! j-loop

      if( nf_ps>0 ) call del2_scalar(ps_dt, del2_cd, 1, nf_ps, bd, npx, npy, gridstruct, domain)

      do j=js,je
         do i=is,ie
! Cap the errors:
            ps_dt(i,j) = sign ( min(10.E2, abs(ps_dt(i,j))), ps_dt(i,j) )
            ps_dt(i,j) = mask(i,j)*ps_dt(i,j) * max( 0., 1.-abs(gz0(i,j)-phis(i,j))/(grav*500.) )
         enddo
      enddo

      if( do_ps_bias ) call ps_bias_correction( ps_dt, is, ie, js, je, bd%isd, bd%ied, bd%jsd, bd%jed, area)

      if ( nudge_debug ) then
           bias = -g0_sum(ps_dt, is, ie, js, je, 1, .false., bd%isd, bd%ied, bd%jsd, bd%jed, area)
           if(master) write(*,*) 'PS bias=', bias
      endif

#ifdef CONSV_HGHT
! Convert tracer moist mixing ratio to mass
       do iq=1,nwat
       do k=1,npz
          do j=js,je
             do i=is,ie
                q(i,j,k,iq) = q(i,j,k,iq) * delp(i,j,k)
             enddo
          enddo
       enddo
       enddo

       do k=1,npz
          do j=js,je
             do i=is,ie
                ua(i,j,k) = ua(i,j,k) * delp(i,j,k)
                va(i,j,k) = va(i,j,k) * delp(i,j,k)
             enddo
          enddo
       enddo

      do j=js,je
         do i=is,ie
            pe2(i,1) = ak(1)
            peln(i,1) = log(pe2(i,1))
         enddo
         do k=2,npz+1
             do i=is,ie
                 pe2(i,k) = pe2(i,k-1) + delp(i,j,k-1)
                peln(i,k) = log(pe2(i,k))
             enddo
         enddo
         do k=1,npz
             do i=is,ie
                pt(i,j,k) = pt(i,j,k)*(peln(i,k+1)-peln(i,k))
             enddo
         enddo
      enddo
#endif

! Update ps:
      do j=js,je
         do i=is,ie
            ps(i,j) = ak(1)
         enddo
      enddo

      rdt = dt / (tau_ps/factor + dt)
      do k=1,npz
         dbk = rdt*(bk(k+1) - bk(k))
         do j=js,je
            do i=is,ie
               delp(i,j,k) = delp(i,j,k) + dbk*ps_dt(i,j)
                   ps(i,j) = delp(i,j,k) + ps(i,j)
            enddo
        enddo
     enddo

#ifdef CONSV_HGHT
      do j=js,je
         do k=2,npz+1
             do i=is,ie
                pe2(i,k) = pe2(i,k-1) + delp(i,j,k-1)
                peln(i,k) = log(pe2(i,k))
             enddo
         enddo
         do k=1,npz
             do i=is,ie
                pt(i,j,k) = pt(i,j,k)/(peln(i,k+1)-peln(i,k))
             enddo
          enddo
      enddo

! Convert tracer density back to moist mixing ratios
       do iq=1,nwat
       do k=1,npz
          do j=js,je
             do i=is,ie
                q(i,j,k,iq) = q(i,j,k,iq) / delp(i,j,k)
             enddo
          enddo
       enddo
       enddo

       do k=1,npz
          do j=js,je
             do i=is,ie
                ua(i,j,k) = ua(i,j,k) / delp(i,j,k)
                va(i,j,k) = va(i,j,k) / delp(i,j,k)
             enddo
          enddo
       enddo
#endif

 end subroutine ps_nudging

 subroutine ps_bias_correction ( ps_dt, is, ie, js, je, isd, ied, jsd, jed, area )
 integer, intent(IN) :: is,  ie,  js, je
 integer, intent(IN) :: isd, ied, jsd,jed
 real, intent(inout):: ps_dt(is:ie,js:je)
 real, intent(IN), dimension(isd:ied,jsd:jed) :: area
!
 real:: esl, total_area
 real:: bias, psum
 integer:: i, j

 total_area = 4.*pi*radius**2
 esl = 0.01       ! Pascal

 bias = g0_sum(ps_dt, is, ie, js, je, 1, .true., isd, ied, jsd, jed, area)

 if ( abs(bias) < esl ) then
      if(master .and. nudge_debug) write(*,*) 'Very small PS bias=', -bias, ' No bais adjustment'
      return
 else
      if(master .and. nudge_debug) write(*,*) 'Significant PS bias=', -bias
 endif

 if ( bias > 0. ) then
     psum = 0.
     do j=js,je
        do i=is,ie
           if ( ps_dt(i,j) > 0. ) then
                psum = psum + area(i,j)
           endif
        enddo
     enddo

     call mp_reduce_sum( psum )
     bias = bias * total_area / psum

     do j=js,je
        do i=is,ie
           if ( ps_dt(i,j) > 0.0 ) then
                ps_dt(i,j) = max(0.0, ps_dt(i,j) - bias)
           endif
        enddo
     enddo
 else
     psum = 0.
     do j=js,je
        do i=is,ie
           if ( ps_dt(i,j) < 0. ) then
                psum = psum + area(i,j)
           endif
        enddo
     enddo

     call mp_reduce_sum( psum )
     bias = bias * total_area / psum

     do j=js,je
        do i=is,ie
           if ( ps_dt(i,j) < 0.0 ) then
                ps_dt(i,j) = min(0.0, ps_dt(i,j) - bias)
           endif
        enddo
     enddo
 endif

 end subroutine ps_bias_correction


 real function g0_sum(p, ifirst, ilast, jfirst, jlast, mode, reproduce, isd, ied, jsd, jed, area)
! Fast version of global sum; reproduced if result rounded to 4-byte
      integer, intent(IN) :: ifirst, ilast
      integer, intent(IN) :: jfirst, jlast
      integer, intent(IN) :: mode  ! if ==1 divided by global area
      logical, intent(IN) :: reproduce
      real,    intent(IN) :: p(ifirst:ilast,jfirst:jlast)      ! field to be summed
      integer, intent(IN) :: isd, ied, jsd, jed
      real,    intent(IN) :: area(isd:ied,jsd:jed)

      integer :: i,j
      real gsum

      gsum = 0.
      do j=jfirst,jlast
         do i=ifirst,ilast
            gsum = gsum + p(i,j)*area(i,j)
         enddo
      enddo
!     call mpp_sum(gsum)    ! does this work?
      call mp_reduce_sum(gsum)

      if ( mode==1 ) then
           g0_sum = gsum / (4.*pi*radius**2)
      else
           g0_sum = gsum
      endif

      if ( reproduce ) g0_sum = real(g0_sum, 4) ! convert to 4-byte real

 end function g0_sum


 subroutine compute_slp(isc, iec, jsc, jec, tm, ps, gz, slp)
 integer, intent(in):: isc, iec, jsc, jec
 real, intent(in), dimension(isc:iec,jsc:jec):: tm, ps, gz
! tm: virtual temperature required as input
 real, intent(out):: slp(isc:iec,jsc:jec)
 integer:: i,j

    do j=jsc,jec
       do i=isc,iec
          slp(i,j) = ps(i,j) * exp( gz(i,j)/(rdgas*(tm(i,j) + 3.25E-3*gz(i,j)/grav)) )
       enddo
    enddo

 end subroutine compute_slp


 subroutine get_obs(Time, dt, zvir, ak, bk, ps, ts, ps_obs, delp, pt, nwat, q, u_obs, v_obs, t_obs, q_obs,  &
                    phis, gz_int, ua, va, u_dt, v_dt, npx, npy, npz, factor, mask, bd, gridstruct, domain)
  type(time_type), intent(in):: Time
  integer,         intent(in):: npz, nwat, npx, npy
  real,            intent(in):: zvir
  real,            intent(in):: dt, factor
  real, intent(in), dimension(npz+1):: ak, bk
  type(fv_grid_bounds_type), intent(IN) :: bd
  real, intent(in), dimension(bd%isd:bd%ied,bd%jsd:bd%jed):: phis
  real, intent(in), dimension(bd%is:bd%ie,bd%js:bd%je):: mask
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed):: ps
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp, pt
  real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: ua, va, u_dt, v_dt
  real, intent(inout)::q(bd%isd:bd%ied,bd%jsd:bd%jed,npz,*)
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: ts, ps_obs
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: u_obs, v_obs, t_obs, q_obs
  real, intent(out)::  gz_int(bd%is:bd%ie,bd%js:bd%je)
  type(fv_grid_type), intent(IN) :: gridstruct
  type(domain2d), intent(INOUT) :: domain
! local:
  real::  tm(bd%is:bd%ie,bd%js:bd%je)
  real(KIND=4), allocatable,dimension(:,:,:):: ut, vt, wt
  real, allocatable,dimension(:,:,:):: uu, vv
  integer :: seconds, days
  integer :: year, month, day, hour, minute, second
  integer :: i,j,k
  real :: alpha, beta
  type(time_type) :: time_p1

      integer :: is,  ie,  js,  je
      integer :: isd, ied, jsd, jed

      is  = bd%is
      ie  = bd%ie
      js  = bd%js
      je  = bd%je
      isd = bd%isd
      ied = bd%ied
      jsd = bd%jsd
      jed = bd%jed


  call get_time (time, seconds, days)
  time_p1 = increment_time(time,time_interval) ! Require two time levels in memory.
                                        ! Without increment, will have 2 of the same
                                        ! time levels in memory.
  call get_date (time_p1, year, month, day, hour, minute, second)

  if ( do_adiabatic_init  ) goto 333
  seconds = seconds - nint(dt)

! Data must be "time_interval" (hr) apart; keep two time levels in memory

  no_obs = .false.
  analysis_time = .false.

  if ( mod(seconds, time_interval) == 0 ) then

    if ( nfile == nfile_total .and. (.not.one_year_files) ) then
         no_obs = .true.
#ifndef DYCORE_SOLO
         forecast_mode = .true.
#endif
         if(print_end_nudge)  then
            print_end_nudge = .false.
            if (master) write(*,*) '*** L-S nudging Ended at', days, seconds
         endif
         return              ! free-running mode
    endif

      ps_dat(:,:,1) = ps_dat(:,:,2)
      if ( nudge_winds ) then
         u_dat(:,:,:,1) = u_dat(:,:,:,2)
         v_dat(:,:,:,1) = v_dat(:,:,:,2)
      endif
      t_dat(:,:,:,1) = t_dat(:,:,:,2)
      q_dat(:,:,:,1) = q_dat(:,:,:,2)

!---------------
! Read next data
!---------------
      if ( .not.one_year_files .or. (one_year_files .and. year.ne.last_year) ) then
         nfile = nfile + 1
      end if
      call get_ncep_analysis ( ps_dat(:,:,2), u_dat(:,:,:,2), v_dat(:,:,:,2),    &
                              t_dat(:,:,:,2), q_dat(:,:,:,2), zvir,  &
                              ts, nfile, file_names(nfile), bd, time=time_p1 ) !!::sdu:: There might be problems
      time_nudge = dt
  else
      time_nudge = time_nudge + dt
  endif

!--------------------
! Time interpolation:
!--------------------

  beta = time_nudge / real(time_interval)

  if ( beta < 0. .or. beta >  (1.+1.E-7) ) then
       if (master) write(*,*) 'Nudging: beta=', beta
       call mpp_error(FATAL,'==> Error from get_obs:data out of range')
  endif

333  continue

  if ( do_adiabatic_init ) then
       beta = 1.; alpha = 0.
      if( nudge_debug .and. master) write(*,*) 'Doing final adiabatic initialization/nudging'
  else
      alpha = 1. - beta
      if( abs(alpha)<1.e-7 )  analysis_time = .true.
  endif

! Warning: ps_data are not adjusted for the differences in terrain yet
  ps_obs(:,:)  = alpha*ps_dat(:,:,1) + beta*ps_dat(:,:,2)

!---------------------------------
!*** nudge & update ps & delp here
!---------------------------------
  if (nudge_ps) then

      allocate ( wt(is:ie,js:je,km) )
      wt(:,:,:) = alpha*t_dat(:,:,:,1) + beta*t_dat(:,:,:,2)
      do j=js,je
         do i=is,ie
            tm(i,j)  = wt(i,j,km)
        enddo
      enddo

      call get_int_hght(gz_int, npz, ak, bk, ps(is:ie,js:je), delp, ps_obs(is:ie,js:je), wt(:,:,:), .false., bd)
      deallocate ( wt )

      allocate ( uu(isd:ied,jsd:jed,npz) )
      allocate ( vv(isd:ied,jsd:jed,npz) )
      uu = ua
      vv = va
      call ps_nudging(dt, factor, npz, ak, bk, ps_obs, mask, tm, ps, phis, delp, uu, vv, pt, nwat, q, bd, npx, npy, gridstruct, domain)
      do k=1,npz
      do j=js,je
         do i=is,ie
            u_dt(i,j,k) = u_dt(i,j,k) + (uu(i,j,k) - ua(i,j,k)) / dt
            v_dt(i,j,k) = v_dt(i,j,k) + (vv(i,j,k) - va(i,j,k)) / dt
        enddo
      enddo
      enddo
      deallocate (uu )
      deallocate (vv )
  endif

  allocate ( ut(is:ie,js:je,npz) )
  allocate ( vt(is:ie,js:je,npz) )

  if ( nudge_winds ) then

       call remap_uv(npz, ak,  bk, ps(is:ie,js:je), delp,  ut,     vt,   &
                     km, ps_dat(is:ie,js:je,1),  u_dat(:,:,:,1), v_dat(:,:,:,1), bd )

       u_obs(:,:,:) = alpha*ut(:,:,:)
       v_obs(:,:,:) = alpha*vt(:,:,:)

       call remap_uv(npz, ak, bk, ps(is:ie,js:je), delp,   ut,      vt,   &
                     km, ps_dat(is:ie,js:je,2),  u_dat(:,:,:,2), v_dat(:,:,:,2), bd )

       u_obs(:,:,:) = u_obs(:,:,:) + beta*ut(:,:,:)
       v_obs(:,:,:) = v_obs(:,:,:) + beta*vt(:,:,:)
  endif

       call remap_tq(npz, ak, bk, ps(is:ie,js:je), delp,  ut,  vt,  &
                     km,  ps_dat(is:ie,js:je,1),  t_dat(:,:,:,1), q_dat(:,:,:,1), zvir, bd)

       t_obs(:,:,:) = alpha*ut(:,:,:)
       q_obs(:,:,:) = alpha*vt(:,:,:)

       call remap_tq(npz, ak, bk, ps(is:ie,js:je), delp,  ut,  vt,  &
                     km,  ps_dat(is:ie,js:je,2),  t_dat(:,:,:,2), q_dat(:,:,:,2), zvir, bd)

       t_obs(:,:,:) = t_obs(:,:,:) + beta*ut(:,:,:)
       q_obs(:,:,:) = q_obs(:,:,:) + beta*vt(:,:,:)

  deallocate ( ut )
  deallocate ( vt )

  if ( nudge_hght ) then
       allocate ( wt(is:ie,js:je,km) )
       wt(:,:,:) = alpha*t_dat(:,:,:,1) + beta*t_dat(:,:,:,2)
       call get_int_hght(gz_int, npz, ak, bk, ps(is:ie,js:je), delp, ps_obs(is:ie,js:je), wt(:,:,:), .true., bd)
       deallocate ( wt )
  endif

 end subroutine get_obs


 subroutine fv_ada_nudge_init(time, axes, npz, zvir, ak, bk, ts, phis, gridstruct, ks, npx, neststruct, bd, domain)
 character(len=17) :: mod_name = 'fv_ada_nudge'
  type(time_type), intent(in):: time
  integer,         intent(in):: axes(4)
  integer,  intent(in):: npz           ! vertical dimension
  real,     intent(in):: zvir
  type(fv_grid_bounds_type), intent(IN) :: bd
  real, intent(in), dimension(bd%isd:bd%ied,bd%jsd:bd%jed):: phis
  real, intent(in), dimension(npz+1):: ak, bk
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: ts
  type(domain2d), intent(in) :: domain
  type(fv_grid_type), target :: gridstruct
  integer,  intent(in) :: ks, npx
  type(fv_nest_type) :: neststruct

  real :: missing_value = -1.e10
  logical found
  integer tsize(4)
  integer :: i, j, j1, f_unit, unit, io, ierr, nt, k
  integer :: ncid
  integer :: year, month, day, hour, minute, second

  integer :: id_restart !< Currently not used for anything other than a return
  !value.

  real, pointer, dimension(:,:,:) :: agrid

  integer :: is,  ie,  js,  je
  integer :: isd, ied, jsd, jed

  integer :: stdout_unit

  stdout_unit = stdout()

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je
  isd = bd%isd
  ied = bd%ied
  jsd = bd%jsd
  jed = bd%jed

   agrid => gridstruct%agrid

   master = is_master()
   do_adiabatic_init = .false.
   deg2rad = pi/180.
   rad2deg = 180./pi

   if (neststruct%nested) then
!!! Assumes no grid stretching
      grid_size = 1.E7/(neststruct%npx_global*neststruct%refinement_of_global)
   else
      grid_size = 1.E7/real(npx-1)         ! mean grid size
   endif

   do nt=1,nfile_max
      file_names(nt) = "No_File_specified"
   enddo

   track_file_name = "No_File_specified"

    read(input_nml_file, nml = fv_ada_nudge_nml, iostat = io)
    ierr = check_nml_error(io,'fv_ada_nudge_nml')

    call write_version_number ( 'FV_ADA_NUDGE_MOD', version )
    if ( master ) then
         f_unit=stdlog()
         write( f_unit, nml = fv_ada_nudge_nml )
         write(*,*) 'ADA nudging initialized.'
    endif

    do nt=1,nfile_max
      if ( file_names(nt) == "No_File_specified" ) then
           nfile_total = nt - 1
           if(master) write(*,*) 'Total of NCEP files specified=', nfile_total
           exit
      endif
    enddo

    id_ht_err = register_diag_field ( mod_name, 'ht_error', axes(1:2), time,        &
                'height_error', 'DEG K', missing_value=missing_value )


! Initialize remapping coefficients:

!   call field_size(file_names(1), 'T', tsize, field_found=found)
!   if ( found ) then
!        im = tsize(1); jm = tsize(2); km = tsize(3)
!        if(master)  write(*,*) 'NCEP analysis dimensions:', tsize
!   else
!        call mpp_error(FATAL,'==> Error from get_ncep_analysis: T field not found')
!   endif
    call open_ncfile( file_names(1), ncid )        ! open the file
    call get_ncdim1( ncid, 'lon', im )
    call get_ncdim1( ncid, 'lat', jm )
    call get_ncdim1( ncid, 'lev', km )
    if(master)  write(*,*) 'NCEP analysis dimensions:', im, jm, km

    allocate ( s2c(is:ie,js:je,4) )
    allocate ( id1(is:ie,js:je) )
    allocate ( id2(is:ie,js:je) )
    allocate ( jdc(is:ie,js:je) )

    allocate (  lon(im) )
    allocate (  lat(jm) )

    call _GET_VAR1 (ncid, 'lon', im, lon )
    call _GET_VAR1 (ncid, 'lat', jm, lat )

! Convert to radian
    do i=1,im
       lon(i) = lon(i) * deg2rad ! lon(1) = 0.
    enddo
    do j=1,jm
       lat(j) = lat(j) * deg2rad
    enddo

    allocate ( ak0(km+1) )
    allocate ( bk0(km+1) )

    call _GET_VAR1 (ncid, 'hyai', km+1, ak0, found )
    if ( .not. found )  ak0(:) = 0.

    call _GET_VAR1 (ncid, 'hybi', km+1, bk0 )
    call close_ncfile( ncid )

! Note: definition of NCEP hybrid is p(k) = a(k)*1.E5 + b(k)*ps
    ak0(:) = ak0(:) * 1.E5
! Limiter to prevent NAN at top during remapping
    if ( bk0(1) < 1.E-9 ) ak0(1) = max(1.e-9, ak0(1))

   if ( master ) then
      do k=1,npz
         write(*,*) k, 0.5*(ak(k)+ak(k+1))+0.5*(bk(k)+bk(k+1))*1.E5,  'del-B=', bk(k+1)-bk(k)
      enddo
   endif

   if ( k_breed==0 ) k_breed = max(1, ks)

   call slp_obs_init

!-----------------------------------------------------------
! Initialize lat-lon to Cubed bi-linear interpolation coeff:
!-----------------------------------------------------------
    call remap_coef(bd, agrid)

! Find bounding latitudes:
    jbeg = jm-1;         jend = 2
    do j=js,je
       do i=is,ie
            j1 = jdc(i,j)
          jbeg = min(jbeg, j1)
          jend = max(jend, j1+1)
       enddo
    enddo

    allocate ( gz0(is:ie,js:je) )
    allocate ( gz3(is:ie,js:je,km+1) )
    allocate (ps_dat(is:ie,js:je,2) )
    allocate ( u_dat(is:ie,js:je,km,2) )
    allocate ( v_dat(is:ie,js:je,km,2) )
    allocate ( t_dat(is:ie,js:je,km,2) )
    allocate ( q_dat(is:ie,js:je,km,2) )


! Get first dataset
    nt = 2
    nfile = 1
    call get_ncep_analysis ( ps_dat(:,:,nt), u_dat(:,:,:,nt), v_dat(:,:,:,nt),     &
                            t_dat(:,:,:,nt), q_dat(:,:,:,nt), zvir,   &
                            ts, nfile, file_names(nfile), bd, time=time )
    if ( one_year_files ) then
       call get_date(time, year, month, day, hour, minute, second)
       last_year = year
    end if

#ifdef ENABLE_ADA

    do j = 1, 361
      alat(j) = -90 + (j-1)*0.5
    end do

    if (filt_halo0 >= 1) then
       filt_halo = filt_halo0
    else
       filt_halo = 1
    end if

    allocate(weight(-filt_halo:filt_halo,-filt_halo:filt_halo,1:size(alat)))
    weight(:,:,:) = 0.0

    do j = 1, size(alat) ! loop for latitude

    weight_sum = 0.0
    do j_sm = -filt_halo, filt_halo
    do i_sm = -filt_halo, filt_halo
      if (abs(alat(j)) <= 35.0) then
         weight(i_sm,j_sm,j) = exp(-(i_sm**2+j_sm**2)/(2.*filt_halo**2))
      elseif (abs(alat(j)) < 45.0) then
         weight(i_sm,j_sm,j) = exp(-(i_sm**2+j_sm**2)/(2.*(filt_halo*((45.-abs(alat(j)))/10.))**2))
      else
         if (abs(i_sm) == 0 .and. abs(j_sm) == 0) then
            weight(i_sm,j_sm,j) = 1.0
         else
            weight(i_sm,j_sm,j) = 0.0
         end if
      end if
      weight_sum = weight_sum + weight(i_sm,j_sm,j)
    end do
    end do
    do j_sm = -filt_halo, filt_halo
    do i_sm = -filt_halo, filt_halo
      weight(i_sm,j_sm,j) = weight(i_sm,j_sm,j)/weight_sum
    end do
    end do

    weight_sum = 0.0
    do j_sm = -filt_halo, filt_halo
    do i_sm = -filt_halo, filt_halo
      weight_sum = weight_sum+weight(i_sm,j_sm,j)
    end do
    end do
    if (abs(weight_sum-1.0) > 1.e-5) then
      print*,'weight_sum=',weight_sum
      call mpp_error(FATAL,'==> Error in weight_sum: is not 1.0')
    end if

    end do ! loop for latitude

    call define_cube_mosaic ('ATM', filt_domain, atm_layout, halo=filt_halo)
    call mpp_get_data_domain(filt_domain, isd_filt,ied_filt,jsd_filt,jed_filt)

    allocate(Atm_var%u_a(isd:ied,jsd:jed,npz))
    allocate(Atm_var%v_a(isd:ied,jsd:jed,npz))
    allocate(Atm_var%t_a(isd:ied,jsd:jed,npz))
    allocate(Atm_var%q_a(isd:ied,jsd:jed,npz),Atm_var%ps_a(isd:ied,jsd:jed))

    allocate(Atm_var%u_adj(isd:ied,jsd:jed,npz))
    allocate(Atm_var%v_adj(isd:ied,jsd:jed,npz))
    allocate(Atm_var%t_adj(isd:ied,jsd:jed,npz))
    allocate(Atm_var%q_adj(isd:ied,jsd:jed,npz),Atm_var%ps_adj(isd:ied,jsd:jed))

    allocate(Atm_var%u(isd_filt:ied_filt,jsd_filt:jed_filt,npz))
    allocate(Atm_var%v(isd_filt:ied_filt,jsd_filt:jed_filt,npz))
    allocate(Atm_var%t(isd_filt:ied_filt,jsd_filt:jed_filt,npz))
    allocate(Atm_var%q(isd_filt:ied_filt,jsd_filt:jed_filt,npz),Atm_var%ps(isd_filt:ied_filt,jsd_filt:jed_filt))
    allocate(Atm_var%dp(isd_filt:ied_filt,jsd_filt:jed_filt,npz),Atm_var%phis(isd_filt:ied_filt,jsd_filt:jed_filt))

    Atm_var%u_a(:,:,:) = 0.0
    Atm_var%v_a(:,:,:) = 0.0
    Atm_var%t_a(:,:,:) = 0.0
    Atm_var%q_a(:,:,:) = 0.0
    Atm_var%ps_a(:,:) = 0.0
    Atm_var%u_adj(:,:,:) = 0.0
    Atm_var%v_adj(:,:,:) = 0.0
    Atm_var%t_adj(:,:,:) = 0.0
    Atm_var%q_adj(:,:,:) = 0.0
    Atm_var%ps_adj(:,:) = 0.0

    Atm_var%u(:,:,:) = 0.0
    Atm_var%v(:,:,:) = 0.0
    Atm_var%t(:,:,:) = 0.0
    Atm_var%q(:,:,:) = 0.0
    Atm_var%dp(:,:,:) = 0.0
    Atm_var%ps(:,:) = 0.0
    Atm_var%phis(:,:) = 0.0

    call init_fv_ada(time, agrid)

    id_u_ncep = register_diag_field ( mod_name, 'u_ncep', axes(1:3), time, &
               'ncep ucomp', 'm/s', missing_value=missing_value )
    id_v_ncep = register_diag_field ( mod_name, 'v_ncep', axes(1:3), time, &
               'ncep vcomp', 'm/s', missing_value=missing_value )
    id_t_ncep = register_diag_field ( mod_name, 't_ncep', axes(1:3), time, &
               'ncep temp', 'DEG K', missing_value=missing_value )
    id_q_ncep = register_diag_field ( mod_name, 'q_ncep', axes(1:3), time, &
               'ncep moist', 'g/kg', missing_value=missing_value )
    id_ps_ncep = register_diag_field ( mod_name, 'ps_ncep', axes(1:2), time, &
               'ncep ps', 'Pa', missing_value=missing_value )
!    id_u_damb = register_diag_field ( mod_name, 'u_damb', axes(1:3), time, &
!               'damb ucomp', 'm/s', missing_value=missing_value )
!    id_v_damb = register_diag_field ( mod_name, 'v_damb', axes(1:3), time, &
!               'damb vcomp', 'm/s', missing_value=missing_value )
!    id_t_damb = register_diag_field ( mod_name, 't_damb', axes(1:3), time, &
!               'damb temp', 'DEG K', missing_value=missing_value )
!    id_q_damb = register_diag_field ( mod_name, 'q_damb', axes(1:3), time, &
!               'damb moist', 'g/kg', missing_value=missing_value )
!    id_ps_damb = register_diag_field ( mod_name, 'ps_damb', axes(1:2), time, &
!               'damb ps', 'Pa', missing_value=missing_value )
    id_u_adj = register_diag_field ( mod_name, 'u_adj', axes(1:3), time, &
               'ada u increments', 'm/s', missing_value=missing_value )
    id_v_adj = register_diag_field ( mod_name, 'v_adj', axes(1:3), time, &
               'ada v increments', 'm/s', missing_value=missing_value )
    id_t_adj = register_diag_field ( mod_name, 't_adj', axes(1:3), time, &
               'ada t increments', 'DEG K', missing_value=missing_value )
    id_q_adj = register_diag_field ( mod_name, 'q_adj', axes(1:3), time, &
               'ada q increments', 'g/kg', missing_value=missing_value )
    id_ps_adj = register_diag_field ( mod_name, 'ps_adj', axes(1:2), time, &
               'ada ps increments', 'Pa', missing_value=missing_value )
    id_u_a = register_diag_field ( mod_name, 'u_a', axes(1:3), time, &
               'pert ucomp', 'm/s', missing_value=missing_value )
    id_v_a = register_diag_field ( mod_name, 'v_a', axes(1:3), time, &
               'pert vcomp', 'm/s', missing_value=missing_value )
    id_t_a = register_diag_field ( mod_name, 't_a', axes(1:3), time, &
               'pert temp', 'DEG K', missing_value=missing_value )
    id_q_a = register_diag_field ( mod_name, 'q_a', axes(1:3), time, &
               'pert moist', 'g/kg', missing_value=missing_value )
    id_ps_a = register_diag_field ( mod_name, 'ps_a', axes(1:2), time, &
               'pert ps', 'Pa', missing_value=missing_value )
    id_u_da = register_diag_field ( mod_name, 'u_da', axes(1:3), time, &
               'da ucomp', 'm/s', missing_value=missing_value )
    id_v_da = register_diag_field ( mod_name, 'v_da', axes(1:3), time, &
               'da vcomp', 'm/s', missing_value=missing_value )
    id_t_da = register_diag_field ( mod_name, 't_da', axes(1:3), time, &
               'da temp', 'DEG K', missing_value=missing_value )
    id_q_da = register_diag_field ( mod_name, 'q_da', axes(1:3), time, &
               'da moist', 'g/kg', missing_value=missing_value )
    id_ps_da = register_diag_field ( mod_name, 'ps_da', axes(1:2), time, &
               'da ps', 'Pa', missing_value=missing_value )

! snz add the following lines for recording the return values from the previous assim run

! set dimensions for register restart
    dim_names_4d(1) = "xaxis_1"
    dim_names_4d(2) = "yaxis_1"
    dim_names_4d(3) = "zaxis_1"
    dim_names_4d(4) = "Time"

    if (open_file(ada_driver_restart, restart_file, "read", domain, is_restart=.true.))
      call fv_io_register_axis(ada_driver_restart, numx=1, numy=1, numz=1, zsize=(/size(Atm_var%u_adj,3)/))
      call register_restart_field(ada_driver_restart, &
           & "u_adj", Atm_var%u_adj(:,:,:), dim_names_4d)
      call register_restart_field(ada_driver_restart, &
           & "v_adj", Atm_var%v_adj(:,:,:), dim_names_4d)
      call register_restart_field(ada_driver_restart, &
           & "t_adj", Atm_var%t_adj(:,:,:), dim_names_4d)
      call register_restart_field(ada_driver_restart, &
           & "q_adj", Atm_var%q_adj(:,:,:), dim_names_4d)
      call register_restart_field(ada_driver_restart, &
           & "ps_adj", Atm_var%ps_adj(:,:), dim_names_4d)

      if ( mpp_pe() .eq. mpp_root_pe() ) then
          write (stdout_unit,*) 'Reading ada restart information from ', 'INPUT/'//trim(restart_file)
      end if
      call read_restart(ada_driver_restart)
      call close_file(ada_driver_restart)
    endif

#endif ! snz for ENABLE_ADA

    module_is_initialized = .true.

    nullify(agrid)

 end subroutine fv_ada_nudge_init


 subroutine get_ncep_analysis ( ps, u, v, t, q, zvir, ts, nfile, fname, bd, time )
  real,     intent(in):: zvir
  character(len=128), intent(in):: fname
  integer,  intent(inout):: nfile
  type(time_type), intent(in), optional :: time
!
  type(fv_grid_bounds_type), intent(IN) :: bd
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: ts
  real, intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: ps
  real(KIND=4), intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,km):: u, v, t, q
! local:
  real(kind=4), allocatable:: wk0(:,:), wk1(:,:), wk2(:,:), wk3(:,:,:)
  real tmean
  integer:: i, j, k, npt
  integer:: i1, i2, j1, ncid
  logical found
  logical:: read_ts = .true.
  logical:: land_ts = .false.
  type(time_type):: time1 ! Jan 1 of current year
  integer :: year, month, day, hour, minute, second
  integer :: days, seconds, days1, seconds1, time_slice
  integer, save :: year_on_first_read = 0 !< year on first read of file during
                                          !! model run
  integer :: is,  ie,  js,  je

  if( .not. file_exists(fname) ) then
     call mpp_error(FATAL,'==> Error from get_ncep_analysis: file not found')
  else
     call open_ncfile( fname, ncid )        ! open the file
     if(master) write(*,*) 'Reading NCEP anlysis file:', fname
  endif

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je

  !!::sdu:: Ability to read data in from 1 year files
  !!::sdu:: need the current time (passed in from calling function?
  if ( one_year_files .and. present(Time) ) then
     call get_time(time, seconds, days)
     call get_date(time, year, month, day, hour, minute, second)
     ! Year file has first day of following year
     ! year_on_first_read is the year on the first read of the model run
     if ( year_on_first_read == 0 ) then
        year_on_first_read = year
     end if
     time1=set_date(year_on_first_read, 1, 1, 0, 0, 0)
     call get_time(time1, seconds1, days1)
     time_slice = (days - days1)*int(seconds_per_day/time_interval) + int(seconds/time_interval) + 1
  else
     time_slice = 1.  !! Assuming one slice per file, as done originally
  end if

  if ( read_ts ) then       ! read skin temperature; could be used for SST
       allocate ( wk1(im,jm) )

       call get_var2_r4( ncid, 'TS', 1,im, 1,jm, wk1, time_slice=time_slice )
!      if ( master ) write(*,*) 'Done reading NCEP TS data'

      if ( .not. land_ts ) then
           allocate ( wk0(im,jm) )
! Read NCEP ORO (1; land; 0: ocean; 2: sea_ice)
           call get_var2_r4( ncid, 'ORO', 1,im, 1,jm, wk0, time_slice=time_slice )

           do j=1,jm
              tmean = 0.
              npt = 0
              do i=1,im
                 if( abs(wk0(i,j)-1.) > 0.99 ) then ! non-land points
                     tmean = tmean + wk1(i,j)
                     npt = npt + 1
                 endif
              enddo
!-------------------------------------------------------
! Replace TS over interior land with zonal mean SST/Ice
!-------------------------------------------------------
              if ( npt /= 0 ) then
                   tmean= tmean / real(npt)
                   do i=1,im
                      if( abs(wk0(i,j)-1.) <= 0.99 ) then   ! land points
                          if ( i==1 ) then
                               i1 = im;     i2 = 2
                          elseif ( i==im ) then
                               i1 = im-1;   i2 = 1
                          else
                               i1 = i-1;    i2 = i+1
                          endif
                          if ( abs(wk0(i2,j)-1.)>0.99 ) then     ! east side has priority
                               wk1(i,j) = wk1(i2,j)
                          elseif ( abs(wk0(i1,j)-1.)>0.99 ) then ! west side
                               wk1(i,j) = wk1(i1,j)
                          else
                               wk1(i,j) = tmean
                          endif
                      endif
                   enddo
              endif
           enddo
           deallocate ( wk0 )
      endif   ! land_ts

      do j=js,je
         do i=is,ie
            i1 = id1(i,j)
            i2 = id2(i,j)
            j1 = jdc(i,j)
            ts(i,j) = s2c(i,j,1)*wk1(i1,j1  ) + s2c(i,j,2)*wk1(i2,j1  ) +  &
                      s2c(i,j,3)*wk1(i2,j1+1) + s2c(i,j,4)*wk1(i1,j1+1)
         enddo
      enddo
      call prt_maxmin('SST_model', ts, is, ie, js, je, 0, 1, 1.)

#ifndef DYCORE_SOLO
! Perform interp to FMS SST format/grid
      call ncep2fms( wk1 )
      if(master) call pmaxmin( 'SST_ncep', sst_ncep, i_sst, j_sst, 1.)
!     if(nfile/=1 .and. master) call pmaxmin( 'SST_anom', sst_anom, i_sst, j_sst, 1.)
#endif
       deallocate ( wk1 )
       if (master) write(*,*) 'Done processing NCEP SST'

  endif     ! read_ts

!----------------------------------
! remap surface pressure and height:
!----------------------------------

     allocate ( wk2(im,jbeg:jend) )
     call get_var2_r4( ncid, 'PS', 1,im, jbeg,jend, wk2, time_slice=time_slice )

     do j=js,je
        do i=is,ie
           i1 = id1(i,j)
           i2 = id2(i,j)
           j1 = jdc(i,j)
           ps(i,j) = s2c(i,j,1)*wk2(i1,j1  ) + s2c(i,j,2)*wk2(i2,j1  ) +  &
                     s2c(i,j,3)*wk2(i2,j1+1) + s2c(i,j,4)*wk2(i1,j1+1)
        enddo
     enddo

     call get_var2_r4( ncid, 'PHIS', 1,im, jbeg,jend, wk2, time_slice=time_slice )

     do j=js,je
        do i=is,ie
           i1 = id1(i,j)
           i2 = id2(i,j)
           j1 = jdc(i,j)
           gz0(i,j) = s2c(i,j,1)*wk2(i1,j1  ) + s2c(i,j,2)*wk2(i2,j1  ) +  &
                      s2c(i,j,3)*wk2(i2,j1+1) + s2c(i,j,4)*wk2(i1,j1+1)
        enddo
     enddo
     call prt_maxmin('ZS_ncep', gz0, is, ie, js, je, 0, 1, 1./grav)
     deallocate ( wk2 )


   allocate ( wk3(1:im, jbeg:jend, 1:km) )

! Winds:
   if ( nudge_winds ) then

      call get_var3_r4( ncid, 'U', 1,im, jbeg,jend, 1,km, wk3, time_slice=time_slice )

      do k=1,km
      do j=js,je
         do i=is,ie
            i1 = id1(i,j)
            i2 = id2(i,j)
            j1 = jdc(i,j)
            u(i,j,k) = s2c(i,j,1)*wk3(i1,j1  ,k) + s2c(i,j,2)*wk3(i2,j1  ,k) +  &
                       s2c(i,j,3)*wk3(i2,j1+1,k) + s2c(i,j,4)*wk3(i1,j1+1,k)
         enddo
      enddo
      enddo

      call get_var3_r4( ncid, 'V', 1,im, jbeg,jend, 1,km, wk3, time_slice=time_slice )

      do k=1,km
      do j=js,je
         do i=is,ie
            i1 = id1(i,j)
            i2 = id2(i,j)
            j1 = jdc(i,j)
            v(i,j,k) = s2c(i,j,1)*wk3(i1,j1  ,k) + s2c(i,j,2)*wk3(i2,j1  ,k) +  &
                       s2c(i,j,3)*wk3(i2,j1+1,k) + s2c(i,j,4)*wk3(i1,j1+1,k)
         enddo
      enddo
      enddo

   endif

!  if ( nudge_virt .or. nudge_q .or.  nudge_hght ) then

! Read in tracers: only sphum at this point
      call get_var3_r4( ncid, 'Q', 1,im, jbeg,jend, 1,km , wk3, time_slice=time_slice )

      do k=1,km
      do j=js,je
         do i=is,ie
            i1 = id1(i,j)
            i2 = id2(i,j)
            j1 = jdc(i,j)
            q(i,j,k) = s2c(i,j,1)*wk3(i1,j1  ,k) + s2c(i,j,2)*wk3(i2,j1  ,k) +  &
                       s2c(i,j,3)*wk3(i2,j1+1,k) + s2c(i,j,4)*wk3(i1,j1+1,k)
         enddo
      enddo
      enddo

      call get_var3_r4( ncid, 'T', 1,im, jbeg,jend, 1,km , wk3, time_slice=time_slice )
      call close_ncfile ( ncid )

      do k=1,km
      do j=js,je
         do i=is,ie
            i1 = id1(i,j)
            i2 = id2(i,j)
            j1 = jdc(i,j)
            t(i,j,k) = s2c(i,j,1)*wk3(i1,j1  ,k) + s2c(i,j,2)*wk3(i2,j1  ,k) +  &
                       s2c(i,j,3)*wk3(i2,j1+1,k) + s2c(i,j,4)*wk3(i1,j1+1,k)
         enddo
      enddo
      enddo

      if ( .not. T_is_Tv ) then
      do k=1,km
      do j=js,je
         do i=is,ie
! The field T in Larry H.'s post processing of NCEP analysis is actually virtual temperature
! before Dec 1, 2005
! Convert t to virtual temperature:
            t(i,j,k) = t(i,j,k)*(1.+zvir*q(i,j,k))
         enddo
      enddo
      enddo
      endif

!  endif

   deallocate ( wk3 )

! nfile = nfile + 1

 end subroutine get_ncep_analysis



 subroutine remap_coef(bd, agrid)

  type(fv_grid_bounds_type), intent(IN) :: bd
  real, intent(IN), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,2) :: agrid

! local:
  real :: rdlon(im)
  real :: rdlat(jm)
  real:: a1, b1
  integer i,j, i1, i2, jc, i0, j0

  integer :: is,  ie,  js,  je

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je


  do i=1,im-1
     rdlon(i) = 1. / (lon(i+1) - lon(i))
  enddo
     rdlon(im) = 1. / (lon(1) + 2.*pi - lon(im))

  do j=1,jm-1
     rdlat(j) = 1. / (lat(j+1) - lat(j))
  enddo

! * Interpolate to cubed sphere cell center
  do 5000 j=js,je

     do i=is,ie

       if ( agrid(i,j,1)>lon(im) ) then
            i1 = im;     i2 = 1
            a1 = (agrid(i,j,1)-lon(im)) * rdlon(im)
       elseif ( agrid(i,j,1)<lon(1) ) then
            i1 = im;     i2 = 1
            a1 = (agrid(i,j,1)+2.*pi-lon(im)) * rdlon(im)
       else
            do i0=1,im-1
            if ( agrid(i,j,1)>=lon(i0) .and. agrid(i,j,1)<=lon(i0+1) ) then
               i1 = i0;  i2 = i0+1
               a1 = (agrid(i,j,1)-lon(i1)) * rdlon(i0)
               go to 111
            endif
            enddo
       endif
111    continue

       if ( agrid(i,j,2)<lat(1) ) then
            jc = 1
            b1 = 0.
       elseif ( agrid(i,j,2)>lat(jm) ) then
            jc = jm-1
            b1 = 1.
       else
          do j0=1,jm-1
          if ( agrid(i,j,2)>=lat(j0) .and. agrid(i,j,2)<=lat(j0+1) ) then
               jc = j0
               b1 = (agrid(i,j,2)-lat(jc)) * rdlat(jc)
               go to 222
          endif
          enddo
       endif
222    continue

       if ( a1<0.0 .or. a1>1.0 .or.  b1<0.0 .or. b1>1.0 ) then
            write(*,*) 'gid=', mpp_pe(), i,j,a1, b1
       endif

       s2c(i,j,1) = (1.-a1) * (1.-b1)
       s2c(i,j,2) =     a1  * (1.-b1)
       s2c(i,j,3) =     a1  *     b1
       s2c(i,j,4) = (1.-a1) *     b1
       id1(i,j) = i1
       id2(i,j) = i2
       jdc(i,j) = jc
     enddo   !i-loop
5000 continue   ! j-loop

 end subroutine remap_coef


#ifndef DYCORE_SOLO
 subroutine ncep2fms( sst )
  real(kind=4), intent(in):: sst(im,jm)
! local:
  real :: rdlon(im)
  real :: rdlat(jm)
  real:: a1, b1
  real:: delx, dely
  real:: xc, yc    ! "data" location
  real:: c1, c2, c3, c4
  integer i,j, i1, i2, jc, i0, j0, it, jt

  do i=1,im-1
     rdlon(i) = 1. / (lon(i+1) - lon(i))
  enddo
     rdlon(im) = 1. / (lon(1) + 2.*pi - lon(im))

  do j=1,jm-1
     rdlat(j) = 1. / (lat(j+1) - lat(j))
  enddo

! * Interpolate to "FMS" 1x1 SST data grid
! lon: 0.5, 1.5, ..., 359.5
! lat: -89.5, -88.5, ... , 88.5, 89.5

  delx = 360./real(i_sst)
  dely = 180./real(j_sst)

  jt = 1
  do 5000 j=1,j_sst

     yc = (-90. + dely * (0.5+real(j-1)))  * deg2rad
     if ( yc<lat(1) ) then
            jc = 1
            b1 = 0.
     elseif ( yc>lat(jm) ) then
            jc = jm-1
            b1 = 1.
     else
          do j0=jt,jm-1
          if ( yc>=lat(j0) .and. yc<=lat(j0+1) ) then
               jc = j0
               jt = j0
               b1 = (yc-lat(jc)) * rdlat(jc)
               go to 222
          endif
          enddo
     endif
222  continue
     it = 1

     do i=1,i_sst
        xc = delx * (0.5+real(i-1)) * deg2rad
       if ( xc>lon(im) ) then
            i1 = im;     i2 = 1
            a1 = (xc-lon(im)) * rdlon(im)
       elseif ( xc<lon(1) ) then
            i1 = im;     i2 = 1
            a1 = (xc+2.*pi-lon(im)) * rdlon(im)
       else
            do i0=it,im-1
            if ( xc>=lon(i0) .and. xc<=lon(i0+1) ) then
               i1 = i0;  i2 = i0+1
               it = i0
               a1 = (xc-lon(i1)) * rdlon(i0)
               go to 111
            endif
            enddo
       endif
111    continue

!      if ( a1<0.0 .or. a1>1.0 .or.  b1<0.0 .or. b1>1.0 ) then
!           write(*,*) 'gid=', mpp_pe(), i,j,a1, b1
!      endif
       c1 = (1.-a1) * (1.-b1)
       c2 =     a1  * (1.-b1)
       c3 =     a1  *     b1
       c4 = (1.-a1) *     b1
! Interpolated surface pressure
       sst_ncep(i,j) = c1*sst(i1,jc  ) + c2*sst(i2,jc  ) +    &
                       c3*sst(i2,jc+1) + c4*sst(i1,jc+1)
     enddo   !i-loop
5000 continue   ! j-loop

 end subroutine ncep2fms
#endif


 subroutine get_int_hght(h_int, npz, ak, bk, ps, delp, ps0, tv, get_hght, bd)
  integer, intent(in):: npz
  real,    intent(in):: ak(npz+1), bk(npz+1)
  type(fv_grid_bounds_type), intent(IN) :: bd
  real,    intent(in), dimension(bd%is:bd%ie,bd%js:bd%je):: ps, ps0
  real, intent(in), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp
  real(KIND=4),  intent(in), dimension(bd%is:bd%ie,bd%js:bd%je,km):: tv
  real,   intent(out), dimension(bd%is:bd%ie,bd%js:bd%je):: h_int  ! g*height
  logical, intent(in):: get_hght
! local:
  real, dimension(bd%is:bd%ie,km+1):: pn0
  real:: logp(bd%is:bd%ie)
  integer i,j,k

  integer :: is,  ie,  js,  je

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je

  h_int(:,:) = 1.E25

  do 5000 j=js,je

     do k=1,km+1
        do i=is,ie
           pn0(i,k) = log( ak0(k) + bk0(k)*ps0(i,j) )
        enddo
     enddo
!------
! Model
!------
     do i=is,ie
        logp(i) = ak(1)
     enddo
     do k=1,k_trop
       do i=is,ie
          logp(i) = logp(i) + delp(i,j,k)
       enddo
     enddo
     do i=is,ie
        logp(i) = log( logp(i) )
        gz3(i,j,km+1) = gz0(i,j)   ! Data Surface geopotential
     enddo

     do k=km,1,-1
        do i=is,ie
           gz3(i,j,k) = gz3(i,j,k+1) + rdgas*tv(i,j,k)*(pn0(i,k+1)-pn0(i,k))
        enddo
     enddo

! Linear in log-p interpolation
     if ( get_hght ) then
     do i=is,ie
        do k=km,1,-1
           if ( logp(i)>=pn0(i,k) .and. logp(i)<=pn0(i,k+1) ) then
                h_int(i,j) = gz3(i,j,k+1) + (gz3(i,j,k)-gz3(i,j,k+1))*(pn0(i,k+1)-logp(i))/(pn0(i,k+1)-pn0(i,k))
               goto 400
          endif
       enddo
400    continue
    enddo
    endif

5000 continue

 end subroutine get_int_hght



 subroutine remap_tq( npz, ak,  bk,  ps, delp,  t,  q,  &
                      kmd, ps0, ta, qa, zvir, bd)
  integer, intent(in):: npz, kmd
  real,    intent(in):: zvir
  real,    intent(in):: ak(npz+1), bk(npz+1)
  type(fv_grid_bounds_type), intent(IN) :: bd
  real,    intent(in), dimension(bd%is:bd%ie,bd%js:bd%je):: ps0
  real,    intent(inout), dimension(bd%is:bd%ie,bd%js:bd%je):: ps
  real, intent(in), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp
  real(KIND=4),    intent(in), dimension(bd%is:bd%ie,bd%js:bd%je,kmd):: ta
  real(KIND=4),    intent(in), dimension(bd%is:bd%ie,bd%js:bd%je,kmd):: qa
  real(KIND=4),    intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: t
! on  input "ta" is virtual temperature
! on output "t" is virtual temperature
  real(KIND=4),    intent(out), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: q
! local:
  real, dimension(bd%is:bd%ie,kmd):: tp, qp
  real, dimension(bd%is:bd%ie,kmd+1):: pe0, pn0
  real, dimension(bd%is:bd%ie,npz):: qn1
  real, dimension(bd%is:bd%ie,npz+1):: pe1, pn1
  integer i,j,k

  integer :: is,  ie,  js,  je

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je



  do 5000 j=js,je

     do k=1,kmd+1
        do i=is,ie
           pe0(i,k) = ak0(k) + bk0(k)*ps0(i,j)
           pn0(i,k) = log(pe0(i,k))
       enddo
     enddo
!------
! Model
!------
     do i=is,ie
        pe1(i,1) = ak(1)
     enddo
     do k=1,npz
       do i=is,ie
          pe1(i,k+1) = pe1(i,k) + delp(i,j,k)
       enddo
     enddo
     do i=is,ie
        ps(i,j) = pe1(i,npz+1)
     enddo
     do k=1,npz+1
        do i=is,ie
           pn1(i,k) = log(pe1(i,k))
        enddo
     enddo

   if ( nudge_q ) then
        do k=1,kmd
           do i=is,ie
              qp(i,k) = qa(i,j,k)
           enddo
        enddo
        call mappm(kmd, pe0, qp, npz, pe1, qn1, is,ie, 0, kord_data)
        do k=1,npz
           do i=is,ie
              q(i,j,k) = qn1(i,k)
           enddo
        enddo
   else
      q(:,:,:) = 0.0
   endif

   do k=1,kmd
      do i=is,ie
         tp(i,k) = ta(i,j,k)
      enddo
   enddo
   call mappm(kmd, pn0, tp, npz, pn1, qn1, is,ie, 1, kord_data)

   do k=1,npz
      do i=is,ie
         t(i,j,k) = qn1(i,k)
      enddo
   enddo

5000 continue

 end subroutine remap_tq


 subroutine remap_uv(npz, ak, bk, ps, delp, u, v, kmd, ps0, u0, v0, bd)
  integer, intent(in):: npz
  real,    intent(in):: ak(npz+1), bk(npz+1)
  type(fv_grid_bounds_type), intent(IN) :: bd
  real,    intent(inout):: ps(bd%is:bd%ie,bd%js:bd%je)
  real, intent(in), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp
  real(KIND=4),    intent(inout), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: u, v
!
  integer, intent(in):: kmd
  real,    intent(in):: ps0(bd%is:bd%ie,bd%js:bd%je)
  real(KIND=4),    intent(in), dimension(bd%is:bd%ie,bd%js:bd%je,kmd):: u0, v0
!
! local:
  real, dimension(bd%is:bd%ie,kmd+1):: pe0
  real, dimension(bd%is:bd%ie,npz+1):: pe1
  real, dimension(bd%is:bd%ie,kmd):: qt
  real, dimension(bd%is:bd%ie,npz):: qn1
  integer i,j,k

  integer :: is,  ie,  js,  je

  is  = bd%is
  ie  = bd%ie
  js  = bd%js
  je  = bd%je


  do 5000 j=js,je
!------
! Data
!------
     do k=1,kmd+1
       do i=is,ie
          pe0(i,k) = ak0(k) + bk0(k)*ps0(i,j)
       enddo
     enddo
!------
! Model
!------
     do i=is,ie
        pe1(i,1) = ak(1)
     enddo
     do k=1,npz
       do i=is,ie
          pe1(i,k+1) = pe1(i,k) + delp(i,j,k)
       enddo
     enddo
     do i=is,ie
        ps(i,j) = pe1(i,npz+1)
     enddo
!------
! map u
!------
      do k=1,kmd
         do i=is,ie
            qt(i,k) = u0(i,j,k)
         enddo
      enddo
      call mappm(kmd, pe0, qt, npz, pe1, qn1, is,ie, -1, kord_data)
      do k=1,npz
         do i=is,ie
            u(i,j,k) = qn1(i,k)
         enddo
      enddo
!------
! map v
!------
      do k=1,kmd
         do i=is,ie
            qt(i,k) = v0(i,j,k)
         enddo
      enddo
      call mappm(kmd, pe0, qt, npz, pe1, qn1, is,ie, -1, kord_data)
      do k=1,npz
         do i=is,ie
            v(i,j,k) = qn1(i,k)
         enddo
      enddo
5000 continue

 end subroutine remap_uv



 subroutine fv_ada_nudge_end

    deallocate ( ps_dat )
    deallocate (  t_dat )
    deallocate (  q_dat )

    if ( nudge_winds ) then
         deallocate ( u_dat )
         deallocate ( v_dat )
    endif

    deallocate ( s2c )
    deallocate ( id1 )
    deallocate ( id2 )
    deallocate ( jdc )

    deallocate ( ak0 )
    deallocate ( bk0 )
    deallocate ( lat )
    deallocate ( lon )

    deallocate ( gz3 )
    deallocate ( gz0 )

#ifdef ENABLE_ADA ! snz

    if (open_file(ada_driver_restart, restart_file, "overwrite", domain, is_restart=.true.)) then
       call fv_io_register_axis(ada_driver_restart, numx=1, numy=1, numz=1, zsize=(/size(Atm_var%u_adj,3)/))
       call register_restart_field(ada_driver_restart, &
            & "u_adj", Atm_var%u_adj(:,:,:), dim_names_4d)
       call register_variable_attribute(ada_driver_restart, &
            & "u_adj", "long_name", "u_adj", str_len=len("u_adj"))
       call register_variable_attribute(ada_driver_restart, &
            & "u_adj", "units", "none", str_len=len("none"))
       call register_restart_field(ada_driver_restart, &
            & "v_adj", Atm_var%v_adj(:,:,:), dim_names_4d)
       call register_variable_attribute(ada_driver_restart, &
            & "v_adj", "long_name", "v_adj", str_len=len("v_adj"))
       call register_variable_attribute(ada_driver_restart, &
            & "v_adj", "units", "none", str_len=len("none"))
       call register_restart_field(ada_driver_restart, &
            & "t_adj", Atm_var%t_adj(:,:,:), dim_names_4d)
       call register_variable_attribute(ada_driver_restart, &
            & "t_adj", "long_name", "t_adj", str_len=len("t_adj"))
       call register_variable_attribute(ada_driver_restart, &
            & "t_adj", "units", "none", str_len=len("none"))
       call register_restart_field(ada_driver_restart, &
            & "q_adj", Atm_var%q_adj(:,:,:), dim_names_4d)
       call register_variable_attribute(ada_driver_restart, &
            & "q_adj", "long_name", "q_adj", str_len=len("q_adj"))
       call register_variable_attribute(ada_driver_restart, &
            & "q_adj", "units", "none", str_len=len("none"))
       call register_restart_field(ada_driver_restart, &
            & "ps_adj", Atm_var%ps_adj(:,:), dim_names_4d)
       call register_variable_attribute(ada_driver_restart, &
            & "ps_adj", "long_name", "ps_adj", str_len=len("ps_adj"))
       call register_variable_attribute(ada_driver_restart, &
            & "ps_adj", "units", "none", str_len=len("none"))
       call write_restart(ada_driver_restart)
       call close_file(ada_driver_restart)
    endif

    deallocate ( Atm_var%u, Atm_var%v, Atm_var%t, Atm_var%u_adj, Atm_var%v_adj, Atm_var%t_adj)
    deallocate ( Atm_var%q, Atm_var%ps, Atm_var%q_adj, Atm_var%ps_adj)

    call ada_end()
#endif ! snz

 end subroutine fv_ada_nudge_end


 subroutine get_tc_mask(time, mask, bd, agrid)
      real :: slp_mask = 100900.    ! crtical SLP to apply mask
! Input
      type(fv_grid_bounds_type), intent(IN) :: bd
      type(time_type), intent(in):: time
      real, intent(inout):: mask(bd%is:bd%ie,bd%js:bd%je)
      real(kind=R_GRID), intent(IN), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,2) :: agrid
! local
      real(kind=R_GRID) :: pos(2)
      real:: slp_o         ! sea-level pressure (Pa)
      real:: w10_o         ! 10-m wind
      real:: r_vor, p_vor
      real:: dist
      integer n, i, j

      integer :: is,  ie,  js,  je

      is  = bd%is
      ie  = bd%ie
      js  = bd%js
      je  = bd%je


    do 5000 n=1,nstorms      ! loop through all storms
!----------------------------------------
! Obtain slp observation
!----------------------------------------
      call get_slp_obs(time, nobs_tc(n), x_obs(1,n), y_obs(1,n), wind_obs(1,n),  mslp_obs(1,n), mslp_out(1,n), rad_out(1,n),   &
                       time_tc(1,n), pos(1), pos(2), w10_o, slp_o, r_vor, p_vor)

      if ( slp_o<880.E2 .or. slp_o>min(slp_env,slp_mask) .or. abs(pos(2))*rad2deg>40. ) goto 5000  ! next storm

      if ( r_vor < 30.E3 ) then
           r_vor = r_min + (slp_env-slp_o)/20.E2*r_inc   ! radius of influence
      endif

      do j=js, je
         do i=is, ie
            dist = great_circle_dist(pos, agrid(i,j,1:2), radius)
            if( dist < 6.*r_vor  ) then
                mask(i,j) = mask(i,j) * ( 1. - mask_fac*exp(-(0.5*dist/r_vor)**2)*min(1.,(slp_env-slp_o)/10.E2) )
            endif
         enddo             ! i-loop
      enddo                ! end j-loop

5000 continue

 end subroutine get_tc_mask


 subroutine breed_slp_inline_ada(nstep, dt, npz, ak, bk, phis, pe, pk, peln, pkz, delp, u, v, pt, q, nwat, zvir, gridstruct, ks, domain_local, bd)
!------------------------------------------------------------------------------------------
! Purpose:  Vortex-breeding by nudging sea-level-pressure towards single point observations
! Note: conserve water mass, geopotential, and momentum at the expense of dry air mass
!------------------------------------------------------------------------------------------
! Input
      integer, intent(in):: nstep, npz, nwat, ks
      real, intent(in):: dt       ! (small) time step in seconds
      real, intent(in):: zvir
      real, intent(in), dimension(npz+1):: ak, bk
      type(fv_grid_bounds_type), intent(IN) :: bd
      real, intent(in):: phis(bd%isd:bd%ied,bd%jsd:bd%jed)
      type(domain2d), intent(INOUT) :: domain_local
! Input/Output
      real, intent(inout):: u(bd%isd:bd%ied,bd%jsd:bd%jed+1,npz)
      real, intent(inout):: v(bd%isd:bd%ied+1,bd%jsd:bd%jed,npz)
      real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp, pt
      real, intent(inout)::q(bd%isd:bd%ied,bd%jsd:bd%jed,npz,*)

      real, intent(inout):: pk(bd%is:bd%ie,bd%js:bd%je, npz+1)          ! pe**kappa
      real, intent(inout):: pe(bd%is-1:bd%ie+1, npz+1,bd%js-1:bd%je+1)  ! edge pressure (pascal)
      real, intent(inout):: pkz(bd%is:bd%ie,bd%js:bd%je,npz)
      real, intent(out):: peln(bd%is:bd%ie,npz+1,bd%js:bd%je)           ! ln(pe)

      type(fv_grid_type), target :: gridstruct
! local
      type(time_type):: time
      real:: ps(bd%is:bd%ie,bd%js:bd%je)
      real:: dist(bd%is:bd%ie,bd%js:bd%je)
      real::   tm(bd%is:bd%ie,bd%js:bd%je)
      real::  slp(bd%is:bd%ie,bd%js:bd%je)
      real(kind=R_GRID):: pos(2)
      real:: slp_o         ! sea-level pressure (Pa)
      real:: w10_o, p_env
      real:: r_vor
      real:: relx0, relx, f1, pbreed, pbtop, delp0, dp0
      real:: ratio, p_count, p_sum, a_sum, mass_sink, delps
      real:: p_lo, p_hi, tau_vt, mslp0
      real:: split_time, fac, pdep, r2, r3
      integer year, month, day, hour, minute, second
      integer n, i, j, k, iq, k0

      real(kind=R_GRID), pointer :: agrid(:,:,:)
      real, pointer :: area(:,:)

      integer :: is,  ie,  js,  je

      is  = bd%is
      ie  = bd%ie
      js  = bd%js
      je  = bd%je



      agrid => gridstruct%agrid_64
      area  => gridstruct%area

    if ( nstorms==0 ) then
         if(master) write(*,*) 'NO TC data to process'
         return
    endif

   if ( k_breed==0 ) k_breed = max(1, ks)


! Advance (local) time
    call get_date(fv_time, year, month, day, hour, minute, second)
    if ( year /= year_track_data ) then
        if (master) write(*,*) 'Warning: The year in storm track data is not the same as model year'
        return
     endif
    time = fv_time   ! fv_time is the time at past time step (set in fv_diag)
    split_time = calday(year, month, day, hour, minute, second) + dt*real(nstep)/86400.

    elapsed_time = elapsed_time + dt
    if ( elapsed_time > nudged_time + 0.1 ) then
         if(print_end_breed)  then
            print_end_breed = .false.
            if (master) write(*,*) '*** Vortext Breeding Ended at', day, hour, minute, second
         endif
         return        !  time to return to forecast mode
    endif

!$omp parallel do default(shared)
    do j=js,je
! ---- Compute ps
       do i=is,ie
          ps(i,j) = ak(1)
       enddo
       do k=1,npz
          do i=is,ie
             ps(i,j) = ps(i,j) + delp(i,j,k)
          enddo
       enddo
! Compute lowest layer air temperature:
       do i=is,ie
!         tm(i,j) = pkz(i,j,npz)*pt(i,j,npz)/(cp_air*(1.+zvir*q(i,j,npz,1)))
          tm(i,j) = pkz(i,j,npz)*pt(i,j,npz) / cp_air        ! virtual temp
       enddo
    enddo
!   call prt_maxmin('TM', tm, is, ie, js, je, 0, 1, 1.)

!$omp parallel do default(shared)
    do k=k_breed+1,npz

       if ( conserve_mom ) then
       do j=js,je+1
          do i=is,ie
             u(i,j,k) = u(i,j,k) * (delp(i,j-1,k)+delp(i,j,k))
          enddo
       enddo
       do j=js,je
          do i=is,ie+1
             v(i,j,k) = v(i,j,k) * (delp(i-1,j,k)+delp(i,j,k))
          enddo
       enddo
       endif

       if ( conserve_hgt ) then
       do j=js,je
          do i=is,ie
! Conserve geopotential
!            pt(i,j,k) = pt(i,j,k)*(pk(i,j,k+1)-pk(i,j,k))
! Conserve total enthalpy
             pt(i,j,k) = pt(i,j,k)*pkz(i,j,k)*delp(i,j,k)
          enddo
       enddo
       endif

! Convert tracer moist mixing ratio to mass
       do iq=1,nwat
          do j=js,je
             do i=is,ie
                q(i,j,k,iq) = q(i,j,k,iq) * delp(i,j,k)
             enddo
          enddo
       enddo

    enddo

    do 5000 n=1,nstorms      ! loop through all storms

      if ( nobs_tc(n) < min_nobs ) goto 5000

! Check min MSLP
      mslp0 = 1013.E2
      do i=1,nobs_tc(n)
         mslp_obs_arg = mslp_obs(i,n)
         mslp0 = min( mslp0, mslp_obs_arg )
      enddo
      if ( mslp0 > min_mslp ) goto 5000

!----------------------------------------
! Obtain slp observation
!----------------------------------------
      call get_slp_obs(time, nobs_tc(n), x_obs(1,n), y_obs(1,n), wind_obs(1,n),  mslp_obs(1,n), mslp_out(1,n), rad_out(1,n),   &
                       time_tc(1,n), pos(1), pos(2), w10_o, slp_o, r_vor, p_env, stime=split_time, fact=fac)

      if ( slp_o<87500. .or. slp_o>slp_env .or. abs(pos(2))*rad2deg>45. ) then
           goto 5000         ! next storm
      endif


      if(nudge_debug .and. master)    &
         write(*,*) 'Vortex breeding for TC:', n, ' slp=',slp_o/100.,pos(1)*rad2deg,pos(2)*rad2deg

! Determine pbtop (top pressure of vortex breeding)
   k0 = k_breed

   if ( use_high_top ) then
#ifdef HIGH_TEST
       if ( slp_o > 1000.E2 ) then
            pbtop = 850.E2
       else
!           pbtop = max(200.E2, 850.E2-20.*(1000.E2-slp_o))
! mp87:
            pbtop = max(100.E2, 850.E2-25.*(1000.E2-slp_o))
#else
       if ( slp_o > 1000.E2 ) then
            pbtop = 750.E2
       else
            pbtop = max(100.E2, 750.E2-20.*(1000.E2-slp_o))
#endif
       endif
   else
! Lower top for vrotex breeding
      if ( slp_o > 1000.E2 ) then
           pbtop = 900.E2
      else
           pbtop = max(500.E2, 900.E2-5.*(1000.E2-slp_o))  ! mp48
      endif
   endif

    do k=1,npz
       pbreed = ak(k) + bk(k)*1.E5
       if ( pbreed>pbtop ) then
            k0 = k
            exit
       endif
    enddo
    k0 = max(k0, k_breed)

      do j=js, je
         do i=is, ie
            dist(i,j) = great_circle_dist( pos, agrid(i,j,1:2), radius)
         enddo
      enddo

      call compute_slp(is, ie, js, je, tm, ps, phis(is:ie,js:je), slp)

    if ( r_vor < 30.E3 .or. p_env<900.E2 ) then

! Compute r_vor & p_env
         r_vor = r_min + (slp_env-slp_o)/25.E2*r_inc

123   continue
      p_count = 0.
        p_sum = 0.
        a_sum = 0.
      do j=js, je
         do i=is, ie
            if( dist(i,j)<(r_vor+del_r) .and. dist(i,j)>r_vor .and. phis(i,j)<250.*grav ) then
                p_count = p_count + 1.
                  p_sum = p_sum + slp(i,j)*area(i,j)
                  a_sum = a_sum + area(i,j)
            endif
         enddo
      enddo

      call mp_reduce_sum(p_count)

      if ( p_count<32. ) then
           if(nudge_debug .and. master) write(*,*) p_count, 'Skipping obs: too few p_count'
           goto 5000
      endif

      call mp_reduce_sum(p_sum)
      call mp_reduce_sum(a_sum)
      p_env = p_sum / a_sum

      if(nudge_debug .and. master) write(*,*) 'Environmental SLP=', p_env/100., ' computed radius=', r_vor/1.E3

      if ( p_env>1015.E2 .or. p_env<920.E2 ) then
         if( nudge_debug ) then
            if(master)  write(*,*) 'Environmental SLP out of bound; skipping obs. p_count=', p_count, p_sum
            call prt_maxmin('SLP_breeding', slp, is, ie, js, je, 0, 1, 0.01)
         endif
         goto 5000
      endif

    endif


      if ( p_env < max(pre0_env, slp_o + 200.0) ) then

         r_vor = r_vor + 25.E3

         if(nudge_debug .and. master) then
            write(*,*) 'Computed environmental SLP too low'
            write(*,*) ' ', p_env/100., slp_o/100.,pos(1)*rad2deg, pos(2)*rad2deg
         endif

         if ( slp_o > 1003.E2 .and.  r_vor > 1000.E3 ) then
!             if(master) write(*,*) 'Failed to size the Vortex for the weak storm'
              goto 5000
         endif

         if ( r_vor < 1250.E3 ) goto 123

!        if(master) write(*,*) 'Failed to size the Vortex; skipping this storm'
         goto 5000

      endif

      tau_vt = tau_vt_slp * (1. + (960.E2-slp_o)/100.E2 )
      tau_vt = max(abs(dt), tau_vt)

      if ( do_adiabatic_init ) then
           relx0  = min(1., 2.*abs(dt)/tau_vt)
      else
           relx0  = min(1., abs(dt)/tau_vt)
      endif

      mass_sink = 0.

!$omp parallel do default(shared) private (f1, p_hi, p_lo, relx, delps, pbreed, mass_sink, dp0, pdep)
      do j=js, je
         do i=is, ie
            if( dist(i,j) < r_vor .and. phis(i,j)<250.*grav ) then
                f1 = dist(i,j)/r_vor
! Compute p_obs: assuming local radial distributions of slp are Gaussian
                p_hi = p_env - (p_env-slp_o) * exp( -r_hi*f1**2 )    ! upper bound
                p_lo = p_env - (p_env-slp_o) * exp( -r_lo*f1**2 )    ! lower bound

                if ( ps(i,j) > p_hi .and. tm(i,j) < tm_max ) then
!                                         do nothing if lowest layer is too hot
! Under-development:
                      relx = relx0*exp( -tau_vt_rad*f1**2 )
                     delps = relx*(ps(i,j) - p_hi) * min( (tm_max-tm(i,j))/10., 1.)
! After mp115
!                    delps = relx*(ps(i,j) - p_hi) * min( (tm_max-tm(i,j))/5., 1.)
                                                    ! Cap the increment to prevent overheating
                                                    ! Note: ps is used here to prevent
                                                    !       over deepening over terrain
                     delps = min(delps, dps_min)
                elseif ( slp(i,j) < p_lo ) then
! Over-development:
                      relx = max(0.5, relx0)
                     delps = relx*(slp(i,j) - p_lo)  ! Note: slp is used here
                else
                     goto 400        ! do nothing; proceed to next storm
                endif

#ifdef SIM_TEST
                pbreed = ak(1)
                do k=1,k0
                   pbreed = pbreed + delp(i,j,k)
                enddo
                f1 = 1. - delps/(ps(i,j)-pbreed)
                do k=k0+1,npz
                   delp(i,j,k) = delp(i,j,k)*f1
                enddo
                mass_sink = mass_sink + delps*area(i,j)
#else
                if ( delps > 0. ) then
                      pbreed = ak(1)
                      do k=1,k0
                         pbreed = pbreed + delp(i,j,k)
                      enddo
                      f1 = 1. - delps/(ps(i,j)-pbreed)
                      do k=k0+1,npz
                         delp(i,j,k) = delp(i,j,k)*f1
                      enddo
                      mass_sink = mass_sink + delps*area(i,j)
                else
                      dp0 = abs(delps)
                      do k=npz,k0+1,-1
                         if ( abs(delps) < 1. ) then
                              delp(i,j,k) = delp(i,j,k) - delps
                              mass_sink = mass_sink + delps*area(i,j)
                              go to 400
                         else
                              pdep = max(1.0, min(abs(0.4*delps), 0.2*dp0,  0.02*delp(i,j,k)))
                              pdep = - min(pdep, abs(delps))
                              delp(i,j,k) = delp(i,j,k) - pdep
                              delps = delps - pdep
                              mass_sink = mass_sink + pdep*area(i,j)
                         endif
                      enddo
                endif
#endif

            endif
400     continue
        enddo        ! end i-loop
      enddo        ! end j-loop

      call mp_reduce_sum(mass_sink)
      if ( abs(mass_sink)<1.E-40 ) goto 5000

      r2 = r_vor + del_r
      r3 = min( 4.*r_vor, max(2.*r_vor, 2500.E3) ) + del_r

      p_sum = 0.
      do j=js, je
         do i=is, ie
            if( dist(i,j)<r3 .and. dist(i,j)>r2 ) then
                p_sum = p_sum + area(i,j)
            endif
         enddo
      enddo

      call mp_reduce_sum(p_sum)
      mass_sink = mass_sink / p_sum ! mean delta pressure to be added back to the environment to conserve mass
      if(master .and. nudge_debug) write(*,*) 'TC#',n, 'Mass tele-ported (pa)=', mass_sink

!$omp parallel do default(shared) private (pbreed, f1)
      do j=js, je
         do i=is, ie
            if( dist(i,j)<r3 .and. dist(i,j)>r2 ) then
                pbreed = ak(1)
                do k=1,k_breed
                   pbreed = pbreed + delp(i,j,k)
                enddo
                f1 = 1. + mass_sink/(ps(i,j)-pbreed)
                do k=k_breed+1,npz
                   delp(i,j,k) = delp(i,j,k)*f1
                enddo
            endif
         enddo
      enddo

! ---- re-compute ps
      do j=js,je
         do i=is,ie
            ps(i,j) = ak(1)
         enddo
         do k=1,npz
            do i=is,ie
               ps(i,j) = ps(i,j) + delp(i,j,k)
            enddo
         enddo
      enddo

5000 continue

!--------------------------
! Update delp halo regions:
!--------------------------
    call mpp_update_domains(delp, domain_local, complete=.true.)

!$omp parallel do default(shared)
    do j=js-1,je+1
       do i=is-1,ie+1
          pe(i,1,j) = ak(1)
       enddo
       do k=2,npz+1
          do i=is-1,ie+1
             pe(i,k,j) = pe(i,k-1,j) + delp(i,j,k-1)
          enddo
       enddo
    enddo

    do k=k_breed+1,npz+1
      do j=js,je
         do i=is,ie
            peln(i,k,j) = log(pe(i,k,j))
              pk(i,j,k) = pe(i,k,j)**kappa
         enddo
      enddo
    enddo

!$omp parallel do default(shared)
    do k=k_breed+1,npz

       if ( conserve_mom ) then
       do j=js,je+1
          do i=is,ie
             u(i,j,k) = u(i,j,k) / (delp(i,j-1,k)+delp(i,j,k))
          enddo
       enddo
       do j=js,je
          do i=is,ie+1
             v(i,j,k) = v(i,j,k) / (delp(i-1,j,k)+delp(i,j,k))
          enddo
       enddo
       endif

       if ( conserve_hgt ) then
       do j=js,je
          do i=is,ie
! Conserve geopotential
!            pt(i,j,k) = pt(i,j,k) / (pk(i,j,k+1)-pk(i,j,k))
! Conserve total enthalpy (static energy)
            pkz(i,j,k) = (pk(i,j,k+1)-pk(i,j,k))/(kappa*(peln(i,k+1,j)-peln(i,k,j)))
             pt(i,j,k) = pt(i,j,k) / (pkz(i,j,k)*delp(i,j,k))
! Conserve total enthalpy
          enddo
       enddo
       endif
    enddo

! Convert tracer mass back to moist mixing ratio

!$omp parallel do default(shared)
    do iq=1,nwat
       do k=k_breed+1,npz
          do j=js,je
             do i=is,ie
                q(i,j,k,iq) = q(i,j,k,iq) / delp(i,j,k)
             enddo
          enddo
       enddo
    enddo

    call mpp_update_domains(pt, domain_local, complete=.true.)

    nullify(agrid)
    nullify(area)

  end subroutine breed_slp_inline_ada


 subroutine breed_srf_winds(time, dt, npz, u_obs, v_obs, ak, bk, ps, phis, delp, ua, va, u_dt, v_dt, pt, q, nwat, zvir, bd, gridstruct)
!------------------------------------------------------------------------------------------
! Purpose:  Vortex-breeding by nudging 1-m winds
!------------------------------------------------------------------------------------------
! Input
      type(time_type), intent(in):: time
      integer, intent(in):: npz, nwat
      real, intent(in):: dt       ! time step in seconds
      real, intent(in):: zvir
      real, intent(in), dimension(npz+1):: ak, bk
      type(fv_grid_bounds_type), intent(IN) :: bd
      real, intent(in):: phis(bd%isd:bd%ied,bd%jsd:bd%jed)
      real, intent(in)::   ps(bd%isd:bd%ied,bd%jsd:bd%jed)
      real, intent(in), dimension(bd%is:bd%ie,bd%js:bd%je,npz):: u_obs, v_obs
      type(fv_grid_type), intent(IN), target :: gridstruct
! Input/Output
      real, intent(inout), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,npz):: delp, pt, ua, va, u_dt, v_dt
      real, intent(inout)::q(bd%isd:bd%ied,bd%jsd:bd%jed,npz,nwat)
! local
      real:: dist(bd%is:bd%ie,bd%js:bd%je), wind(bd%is:bd%ie,bd%js:bd%je)
      real::  slp(bd%is:bd%ie,bd%js:bd%je)
      real(kind=R_GRID):: pos(2)
      real:: slp_o         ! sea-level pressure (Pa)
      real:: w10_o, p_env
      real:: r_vor, pc, p_count
      real:: r_max, speed, ut, vt, speed_local        ! tangent wind speed
      real:: u_bg, v_bg, mass, t_mass
      real:: relx0, relx, f1, rdt
      real:: z0, mslp0
      real:: zz = 35.           ! mid-layer height at the lowest model level
      real:: wind_fac           ! Computed ( ~ 1.2)
      integer n, i, j, k, iq

      real, pointer :: area(:,:)
      real(kind=R_GRID), pointer :: vlon(:,:,:), vlat(:,:,:), agrid(:,:,:)

      integer :: is,  ie,  js,  je

      is  = bd%is
      ie  = bd%ie
      js  = bd%js
      je  = bd%je

      area => gridstruct%area
      vlon => gridstruct%vlon
      vlat => gridstruct%vlat
      agrid => gridstruct%agrid_64

    if ( nstorms==0 ) then
         if(master) write(*,*) 'NO TC data to process'
         return
    endif

       rdt = 1./dt
    relx0  = min(1., dt/tau_vt_wind)

!$omp parallel do default(shared)
    do j=js, je
       do i=is, ie
           slp(i,j) = ps(i,j)*exp(phis(i,j)/(rdgas*(pt(i,j,npz)+3.25E-3*phis(i,j)/grav)))
          wind(i,j) = sqrt( ua(i,j,npz)**2 + va(i,j,npz)**2 )
       enddo
    enddo

!omp parallel do default(shared) private(pos, w10_o, slp_o, r_vor, p_env)
    do 3000 n=1,nstorms  ! loop through all storms

      if ( nobs_tc(n) < min_nobs ) goto 3000

! Check min MSLP
      mslp0 = 1013.E2
      do i=1,nobs_tc(n)
         mslp_obs_arg = mslp_obs(i,n)
         mslp0 = min( mslp0, mslp_obs_arg )
      enddo
      if ( mslp0 > min_mslp ) goto 3000

!----------------------------------------
! Obtain slp observation
!----------------------------------------
      call get_slp_obs(time, nobs_tc(n), x_obs(1,n), y_obs(1,n), wind_obs(1,n),  mslp_obs(1,n), mslp_out(1,n), rad_out(1,n),   &
                       time_tc(1,n), pos(1), pos(2), w10_o, slp_o, r_vor, p_env)

      if ( slp_o<90000. .or. slp_o>slp_env .or. abs(pos(2))*rad2deg>35. ) goto 3000         ! next storm


      do j=js, je
         do i=is, ie
            dist(i,j) = great_circle_dist( pos, agrid(i,j,1:2), radius )
         enddo
      enddo

      r_vor = r_min + (slp_env-slp_o)/25.E2*r_inc

!----------------------------------------------------

! * Find model's SLP center nearest to the observation
! * Find maximum wind speed at the lowest model level

     speed_local = 0.
           r_max = -999.
              pc = 1013.E2
     p_count = 0.
     do j=js, je
        do i=is, ie
           if( dist(i,j) < r_vor ) then

! Counting the "land" points:
               if ( dist(i,j)<0.5*r_vor .and. abs(phis(i,j))>2.*grav )  p_count = p_count + 1.

               pc = min(pc, slp(i,j))

               if ( speed_local < wind(i,j) ) then
                    speed_local = wind(i,j)
                    r_max = dist(i,j)
               endif

           endif
        enddo
     enddo

     call mp_reduce_sum(p_count)
     if ( p_count>32 ) goto 3000  ! over/near rough land

     if ( w10_o < 0. ) then   ! 10-m wind obs is not available
! Uses Atkinson_Holliday wind-pressure correlation
          w10_o = 3.446778 * (1010.-slp_o/100.)**0.644
     endif

     speed = speed_local
     call mp_reduce_max(speed)     ! global max wind (near storm)
     call mp_reduce_min(pc)

    if ( speed_local < speed ) then
         r_max = -999.
    endif
    call mp_reduce_max(r_max)
    if( r_max<0. ) call mpp_error(FATAL,'==> Error in r_max')

! ---------------------------------------------------
! Determine surface wind speed and radius for nudging
! ---------------------------------------------------

! Compute surface roughness z0 from w10, based on Eq (4) & (5) from Moon et al. 2007
     if ( w10_o > 12.5 ) then
          z0 = (0.085*w10_o - 0.58) * 1.E-3
! z0 (w10=40) = 2.82E-3
!         z0 = min( z0, 2.82E-3 )

     else
          z0 = 0.0185/grav*(0.001*w10_o**2 + 0.028*w10_o)**2
     endif

! lowest layer height: zz

     wind_fac = log(zz/z0) / log(10./z0)
     if( nudge_debug .and. master ) write(*,*) 'Wind adjustment factor=', wind_fac
     if( wind_fac<1. ) call mpp_error(FATAL,'==> Error in wind_fac')

     if ( pc < slp_o ) then
!--
!         The storm in the model is over developed
!         if ( (pc+3.0E2)>slp_o .or. speed <= w10_o ) go to 3000    ! next storm
!--
! using radius (r_max) as dtermined above;
! What if model's pressure center is very far from the observed?
! using obs wind
          speed = wind_fac*w10_o
     else
!         The storm in the model is under developed; using max wind
          speed = max(wind_fac*w10_o, speed)
          if ( pc>1009.E2 )  r_max = 0.5 * r_vor
     endif

! More adjustment

! Some bounds on the radius of maximum wind:
     r_max = max(2.5*grid_size, r_max)      ! at least 2.5X the grid size
     r_max = min(0.75*r_vor, r_max)

     t_mass = 0.
     u_bg = 0.
     v_bg = 0.

     if ( add_bg_wind ) then
       p_count = 0.
       do j=js, je
          do i=is, ie
           if( dist(i,j) <= min(r_vor,2.*r_fac*r_max) .and. phis(i,j)<2.*grav ) then
               mass = area(i,j)*delp(i,j,npz)
!-- using model winds ----------------------------------
!              u_bg = u_bg + ua(i,j,npz)*mass
!              v_bg = v_bg + va(i,j,npz)*mass
!-------------------------------------------------------
! Using analysis winds
               u_bg = u_bg + u_obs(i,j,npz)*mass
               v_bg = v_bg + v_obs(i,j,npz)*mass
               t_mass = t_mass + mass
               p_count = p_count + 1.
           endif
          enddo
       enddo
       call mp_reduce_sum(p_count)
       if ( p_count<16. ) go to 3000

       call mp_reduce_sum(t_mass)
       call mp_reduce_sum(u_bg)
       call mp_reduce_sum(v_bg)
       u_bg = u_bg / t_mass
       v_bg = v_bg / t_mass
!      if ( master ) write(*,*) pos(2)*rad2deg, 'vortex bg wind=', u_bg, v_bg
     endif

     relx = relx0
     k = npz                 ! lowest layer only
! Nudge wind in the "inner core":
      do j=js, je
         do i=is, ie
            if( dist(i,j) <= min(r_vor, r_fac*r_max) .and. phis(i,j)<2.*grav ) then
                f1 = dist(i,j)/r_max
                relx = relx0*exp( -tau_vt_rad*f1**2 )
                if( dist(i,j)<=r_max ) then
                    speed_local = speed * f1
                else
                    speed_local = speed / f1**0.75
                endif
                call tangent_wind(vlon(i,j,1:3), vlat(i,j,1:3), speed_local, pos, agrid(i,j,1:2), ut, vt)
                ut = ut + u_bg
                vt = vt + v_bg
                u_dt(i,j,k) = u_dt(i,j,k) + relx*(ut-ua(i,j,k)) * rdt
                v_dt(i,j,k) = v_dt(i,j,k) + relx*(vt-va(i,j,k)) * rdt
! Update:
                ua(i,j,k) = ua(i,j,k) + relx*(ut-ua(i,j,k))
                va(i,j,k) = va(i,j,k) + relx*(vt-va(i,j,k))
            endif
400     continue
        enddo        ! end i-loop
      enddo        ! end j-loop

3000 continue

  end subroutine breed_srf_winds

  subroutine tangent_wind ( elon, elat, speed, po, pp, ut, vt )
  real, intent(in):: speed
  real(kind=R_GRID), intent(in):: po(2), pp(2)
  real(kind=R_GRID), intent(in):: elon(3), elat(3)
  real, intent(out):: ut, vt
! local
  real(kind=R_GRID):: e1(3), eo(3), ep(3), op(3)

  call latlon2xyz(po, eo)
  call latlon2xyz(pp, ep)

  op(:) = ep(:) - eo(:)
  call normalize_vect( op )

  call vect_cross(e1, ep, eo)

  ut = speed * (e1(1)*elon(1) + e1(2)*elon(2) + e1(3)*elon(3))
  vt = speed * (e1(1)*elat(1) + e1(2)*elat(2) + e1(3)*elat(3))

! SH:
  if ( po(2) < 0. ) then
       ut = -ut
       vt = -vt
  endif

  end subroutine tangent_wind


  subroutine get_slp_obs(time, nobs, lon_obs, lat_obs, w10, mslp, slp_out, r_out, time_obs,    &
                         x_o, y_o, w10_o, slp_o, r_vor, p_vor, stime, fact)
! Input
    type(time_type), intent(in):: time
    integer, intent(in)::  nobs   ! number of observations in this particular storm
    real(KIND=4), intent(in)::  lon_obs(nobs)
    real(KIND=4), intent(in)::  lat_obs(nobs)
    real(KIND=4), intent(in)::      w10(nobs)        ! observed 10-m widn speed
    real(KIND=4), intent(in)::     mslp(nobs)        ! observed SLP in pa
    real(KIND=4), intent(in)::  slp_out(nobs)        ! slp at r_out
    real(KIND=4), intent(in)::    r_out(nobs)        !
    real(KIND=4), intent(in):: time_obs(nobs)
    real, optional, intent(in):: stime
    real, optional, intent(out):: fact
! Output
    real(kind=R_GRID), intent(out):: x_o , y_o      ! position of the storm center
    real, intent(out):: w10_o          ! 10-m wind speed
    real, intent(out):: slp_o          ! Observed sea-level-pressure (pa)
    real, intent(out):: r_vor, p_vor
! Internal:
    real:: t_thresh
      real(kind=R_GRID):: p1(2), p2(2)
      real time_model
      real(kind=R_GRID) fac
      integer year, month, day, hour, minute, second, n

      t_thresh = 600./86400.  ! unit: days

       w10_o = -100000.
       slp_o = -100000.
         x_o = -100.*pi
         y_o = -100.*pi
       p_vor = -1.E10
       r_vor = -1.E10

   if ( present(stime) ) then
      time_model = stime
   else
      call get_date(time, year, month, day, hour, minute, second)

      if ( year /= year_track_data ) then
           if (master) write(*,*) 'Warning: The year in storm track data is not the same as model year'
           return
      endif

      time_model = calday(year, month, day, hour, minute, second)
!     if(nudge_debug .and. master) write(*,*) 'Model:', time_model, year, month, day, hour, minute, second
   endif

!-------------------------------------------------------------------------------------------
!     if ( time_model <= time_obs(1)  .or.  time_model >= time_obs(nobs) ) then
!          return
!-------------------------------------------------------------------------------------------

      if ( time_model <= (time_obs(1)-t_thresh)  .or.  time_model >= time_obs(nobs) ) return

      if ( time_model <=  time_obs(1) ) then
!--
! This is an attempt to perform vortex breeding several minutes before the first available observation
!--
                 w10_o =     w10(1)
                 slp_o =    mslp(1)
                   x_o = lon_obs(1)
                   y_o = lat_obs(1)
                 if ( present(fact) )  fact = 1.25
      else
           do n=1,nobs-1
             if( time_model >= time_obs(n) .and. time_model <= time_obs(n+1) ) then
                   fac = (time_model-time_obs(n)) / (time_obs(n+1)-time_obs(n))
                 w10_o =     w10(n) + (    w10(n+1)-    w10(n)) * fac
                 slp_o =    mslp(n) + (   mslp(n+1)-   mslp(n)) * fac
! Trajectory interpolation:
! Linear in (lon,lat) space
!                  x_o = lon_obs(n) + (lon_obs(n+1)-lon_obs(n)) * fac
!                  y_o = lat_obs(n) + (lat_obs(n+1)-lat_obs(n)) * fac
                 p1(1) = lon_obs(n);     p1(2) = lat_obs(n)
                 p2(1) = lon_obs(n+1);   p2(2) = lat_obs(n+1)
                 call intp_great_circle(fac, p1, p2, x_o, y_o)
!----------------------------------------------------------------------
                  if ( present(fact) )   fact = 1. + 0.25*cos(fac*2.*pi)
! Additional data from the extended best track
!                if ( slp_out(n)>0. .and. slp_out(n+1)>0. .and. r_out(n)>0. .and. r_out(n+1)>0. ) then
!                     p_vor = slp_out(n) + ( slp_out(n+1) - slp_out(n)) * fac
!                     r_vor =   r_out(n) + (   r_out(n+1) -   r_out(n)) * fac
!                endif
                 return
             endif
           enddo
      endif

  end subroutine get_slp_obs


  subroutine slp_obs_init
  integer:: unit, n, nobs
  character(len=3):: GMT
  character(len=9):: ts_name
  character(len=19):: comment
  integer:: mmddhh, yr, year, month, day, hour, MPH, islp
  integer:: it, i1, i2, p_ring, d_ring
  real:: lon_deg, lat_deg, cald, slp, mps

  nobs_tc(:) = 0
  time_tc(:,:) = 0.
  wind_obs(:,:) = -100000.
  mslp_obs(:,:) = -100000.
  x_obs(:,:) = - 100.*pi
  y_obs(:,:) = - 100.*pi

  mslp_out(:,:) = -1.E10
   rad_out(:,:) = -1.E10

  if( track_file_name == "No_File_specified" ) then
      if(master) write(*,*) 'No TC track file specified'
      return
  else
      unit = get_unit()
      open( unit, file=track_file_name)
  endif

  read(unit, *) year
  if(master) write(*,*) 'Reading TC track data for YEAR=', year

  year_track_data = year

  nstorms = 0
     nobs = 0
    month = 99

  if ( ibtrack ) then

!---------------------------------------------------------------
! The data format is from Ming Zhoa's processed ibTrack datasets
!---------------------------------------------------------------

    read(unit, *) ts_name, nobs, yr, month, day, hour

    if ( yr /= year ) then
         if(master) write(*, *) 'Year inconsistency found !!!'
         call mpp_error(FATAL,'==> Error in reading best track data')
    endif

    do while ( ts_name=='start' )

               nstorms  = nstorms + 1
       nobs_tc(nstorms) = nobs       ! observation count for this storm
       if(nudge_debug .and. master) write(*, *) 'Read Data for TC#', nstorms, nobs

       do it=1, nobs
          read(unit, *) lon_deg, lat_deg, mps, slp, yr, month, day, hour
!         if ( yr /= year ) then
!             if(master) write(*, *) 'Extended to year + 1', yr
!         endif
          cald = calday(yr, month, day, hour, 0, 0)
          time_tc(it,nstorms) = cald
          if(nudge_debug .and. master) write(*, 100) cald, month, day, hour, lon_deg, lat_deg, mps, slp

          wind_obs(it,nstorms) = mps       ! m/s
          mslp_obs(it,nstorms) = 100.*slp
             y_obs(it,nstorms) = lat_deg * deg2rad
             x_obs(it,nstorms) = lon_deg * deg2rad
       enddo

       read(unit, *) ts_name, nobs, yr, month, day, hour
    enddo
100  format(1x, f9.2, 1x, i3, 1x, i2, 1x, i2, 1x, f6.1, 1x, f6.1, 1x, f4.1, 1x, f6.1)

  else

  do while ( month /= 0 )

     read(unit, *) month, day, hour, GMT, lat_deg, lon_deg, MPH, islp, comment

     select case (month)

     case (99)                ! New storm record to start
          nstorms = nstorms + 1
          nobs = 0
          if(master) write(*, *) 'Reading data for TC#', nstorms, comment
     case ( 0)                ! end of record
          if(master) write(*, *) 'End of record reached'
     case default
           nobs = nobs + 1
           cald = calday(year, month, day, hour, 0, 0)
           time_tc(nobs,nstorms) = cald
           nobs_tc(nstorms) = nobs       ! observation count for this storm

          if(master) write(*, 200) nobs, cald,  month, day, hour, GMT, lat_deg, lon_deg, MPH, islp, comment
          mslp_obs(nobs,nstorms) = 100. * real(islp)
             y_obs(nobs,nstorms) = lat_deg * deg2rad
          if ( GMT == 'GMT' ) then
!                                  Transfrom x from (-180 , 180) to (0, 360) then to radian
             if ( lon_deg < 0 ) then
                  x_obs(nobs,nstorms) = (360.+lon_deg) * deg2rad
             else
                  x_obs(nobs,nstorms) = (360.-lon_deg) * deg2rad
             endif
          elseif ( GMT == 'PAC' ) then   ! Pacific storms
             x_obs(nobs,nstorms) = lon_deg * deg2rad
          endif
     end select

  enddo

  endif

  close(unit)

  if(master) then
     write(*,*) 'TC vortex breeding: total storms=', nstorms
     if ( nstorms/=0 ) then
          do n=1,nstorms
             write(*, *) 'TC#',n, ' contains ',  nobs_tc(n),' observations'
          enddo
     endif
  endif

200  format(i3, 1x,f9.4, 1x, i2, 1x, i2, 1x, i2, 1x, a3, f5.1, 1x, f5.1, 1x, i3, 1x, i4, 1x, a19)

  end subroutine slp_obs_init


  real function calday(year, month, day, hour, minute, sec)
! For time interpolation; Julian day (0 to 365 for non-leap year)
! input:
    integer, intent(in):: year, month, day, hour
    integer, intent(in):: minute, sec
! Local:
      integer n, m, ds, nday
      real tsec
      integer days(12)
      data days /31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/

      ds = day - 1

      if( month /= 1 ) then
          do m=1, month-1
            if( m==2  .and. leap_year(year) ) then
                ds = ds + 29
            else
                ds = ds + days(m)
            endif
          enddo
      endif

      if ( leap_year(year_track_data) ) then
           nday = 366
      else
           nday = 365
      endif

      calday = real((year-year_track_data)*nday + ds)  + real(hour*3600 + minute*60 + sec)/86400.

  end function calday


  logical function leap_year(ny)
  integer, intent(in):: ny
!
! Determine if year ny is a leap year
! Author: S.-J. Lin
   integer ny00
!
! No leap years prior to 0000
!
      parameter ( ny00 = 0000 )   ! The threshold for starting leap-year

      if( ny >= ny00 ) then
         if( mod(ny,100) == 0. .and. mod(ny,400) == 0. ) then
             leap_year = .true.
         elseif( mod(ny,4) == 0. .and. mod(ny,100) /= 0.  ) then
             leap_year = .true.
         else
             leap_year = .false.
         endif
      else
          leap_year = .false.
      endif

  end function leap_year


 subroutine pmaxmin( qname, a, imax, jmax, fac )

      character(len=*)  qname
      integer imax, jmax
      integer i, j
      real a(imax,jmax)

      real qmin(jmax), qmax(jmax)
      real pmax, pmin
      real fac                     ! multiplication factor

      do j=1,jmax
         pmax = a(1,j)
         pmin = a(1,j)
         do i=2,imax
            pmax = max(pmax, a(i,j))
            pmin = min(pmin, a(i,j))
         enddo
         qmax(j) = pmax
         qmin(j) = pmin
      enddo
!
! Now find max/min of amax/amin
!
            pmax = qmax(1)
            pmin = qmin(1)
         do j=2,jmax
            pmax = max(pmax, qmax(j))
            pmin = min(pmin, qmin(j))
         enddo

      write(*,*) qname, ' max = ', pmax*fac, ' min = ', pmin*fac

 end subroutine pmaxmin


 subroutine del2_uv(du, dv, cd, kmd, ntimes, bd, npx, npy, gridstruct, domain)
! This routine is for filtering the wind tendency
   integer, intent(in):: kmd
   integer, intent(in):: ntimes
   real,    intent(in):: cd            ! cd = K * da_min;   0 < K < 0.25
   type(fv_grid_bounds_type), intent(IN) :: bd
   real, intent(inout):: du(bd%is:bd%ie,bd%js:bd%je,kmd)
   real, intent(inout):: dv(bd%is:bd%ie,bd%js:bd%je,kmd)
   integer, intent(IN) :: npx, npy
   type(fv_grid_type), intent(IN), target :: gridstruct
  type(domain2d), intent(INOUT) :: domain
! local:
  real(kind=R_GRID), pointer, dimension(:,:,:) :: vlon, vlat
   real, dimension(bd%is:bd%ie,bd%js:bd%je,kmd):: v1, v2, v3
   integer i,j,k

   integer :: is,  ie,  js,  je

   is  = bd%is
   ie  = bd%ie
   js  = bd%js
   je  = bd%je

   vlon => gridstruct%vlon
   vlat => gridstruct%vlat

! transform to 3D Cartesian:
!$omp parallel do default(shared)
   do k=1,kmd
      do j=js,je
         do i=is,ie
            v1(i,j,k) = du(i,j,k)*vlon(i,j,1) + dv(i,j,k)*vlat(i,j,1)
            v2(i,j,k) = du(i,j,k)*vlon(i,j,2) + dv(i,j,k)*vlat(i,j,2)
            v3(i,j,k) = du(i,j,k)*vlon(i,j,3) + dv(i,j,k)*vlat(i,j,3)
         enddo
      enddo
   enddo

! Filter individual components as scalar:
   call del2_scalar( v1(is,js,1), cd, kmd, ntimes, bd, npx, npy, gridstruct, domain )
   call del2_scalar( v2(is,js,1), cd, kmd, ntimes, bd, npx, npy, gridstruct, domain )
   call del2_scalar( v3(is,js,1), cd, kmd, ntimes, bd, npx, npy, gridstruct, domain )

! Convert back to lat-lon components:
!$omp parallel do default(shared)
   do k=1,kmd
      do j=js,je
         do i=is,ie
            du(i,j,k) = v1(i,j,k)*vlon(i,j,1) + v2(i,j,k)*vlon(i,j,2) + v3(i,j,k)*vlon(i,j,3)
            dv(i,j,k) = v1(i,j,k)*vlat(i,j,1) + v2(i,j,k)*vlat(i,j,2) + v3(i,j,k)*vlat(i,j,3)
         enddo
      enddo
   enddo

 end subroutine del2_uv

 subroutine del2_scalar(qdt, cd, kmd, nmax, bd,  npx, npy, gridstruct, domain)
! This routine is for filtering the physics tendency
   integer, intent(in):: kmd
   integer, intent(in):: nmax          ! must be no greater than 3
   real,    intent(in):: cd            ! cd = K * da_min;   0 < K < 0.25
   type(fv_grid_bounds_type), intent(IN) :: bd
   real, intent(inout):: qdt(bd%is:bd%ie,bd%js:bd%je,kmd)
   integer, intent(IN) :: npx, npy
   type(fv_grid_type), intent(IN), target :: gridstruct
  type(domain2d), intent(INOUT) :: domain
! local:
   real::  q(bd%isd:bd%ied,bd%jsd:bd%jed,kmd)
   real:: fx(bd%isd:bd%ied+1,bd%jsd:bd%jed), fy(bd%isd:bd%ied,bd%jsd:bd%jed+1)
   integer i,j,k, n, nt, ntimes
   real :: damp

   integer :: is,  ie,  js,  je
   integer :: isd, ied, jsd, jed

  real, pointer, dimension(:,:)   :: rarea, area

  real, pointer, dimension(:,:) :: sina_u, sina_v
  real, pointer, dimension(:,:,:) :: sin_sg

  real, pointer, dimension(:,:) :: dx, dy, rdxc, rdyc

  logical, pointer :: nested, sw_corner, se_corner, nw_corner, ne_corner

   is  = bd%is
   ie  = bd%ie
   js  = bd%js
   je  = bd%je
   isd = bd%isd
   ied = bd%ied
   jsd = bd%jsd
   jed = bd%jed

   area => gridstruct%area
  rarea => gridstruct%rarea

  sina_u => gridstruct%sina_u
  sina_v => gridstruct%sina_v
  sin_sg => gridstruct%sin_sg

  dx     => gridstruct%dx
  dy     => gridstruct%dy
  rdxc   => gridstruct%rdxc
  rdyc   => gridstruct%rdyc

  nested => gridstruct%nested
  sw_corner => gridstruct%sw_corner
  se_corner => gridstruct%se_corner
  nw_corner => gridstruct%nw_corner
  ne_corner => gridstruct%ne_corner

   ntimes = min(3, nmax)

   damp = cd * gridstruct%da_min

!$omp parallel do default(shared)
   do k=1,kmd
      do j=js,je
         do i=is,ie
            q(i,j,k) = qdt(i,j,k)
         enddo
      enddo
   enddo
   call timing_on('COMM_TOTAL')
   call mpp_update_domains(q, domain, complete=.true.)
   call timing_off('COMM_TOTAL')

   do n=1,ntimes

   nt = ntimes - n

!$omp parallel do default(shared) private(fx, fy)
   do k=1,kmd

      if(nt>0) call copy_corners(q(isd,jsd,k), npx, npy, 1, nested, bd, &
           sw_corner, se_corner, nw_corner, ne_corner)
      do j=js-nt,je+nt
         do i=is-nt,ie+1+nt
            fx(i,j) = dy(i,j)*sina_u(i,j)*(q(i-1,j,k)-q(i,j,k))*rdxc(i,j)
         enddo
         if (is == 1) fx(i,j) = dy(is,j)*(q(is-1,j,k)-q(is,j,k))*rdxc(is,j)* &
            0.5*(sin_sg(1,1,j) + sin_sg(3,0,j))
         if (ie+1 == npx) fx(i,j) = dy(ie+1,j)*(q(ie,j,k)-q(ie+1,j,k))*rdxc(ie+1,j)* &
            0.5*(sin_sg(1,npx,j) + sin_sg(3,npx-1,j))
      enddo

      if(nt>0) call copy_corners(q(isd,jsd,k), npx, npy, 2, nested, bd, &
           sw_corner, se_corner, nw_corner, ne_corner)
      do j=js-nt,je+1+nt
         if (j == 1 .OR. j == npy) then
            do i=is-nt,ie+nt
               fy(i,j) = dx(i,j)*(q(i,j-1,k)-q(i,j,k))*rdyc(i,j) &
                    *0.5*(sin_sg(2,i,j) + sin_sg(4,i,j-1) )
            enddo
         else
            do i=is-nt,ie+nt
               fy(i,j) = dx(i,j)*sina_v(i,j)*(q(i,j-1,k)-q(i,j,k))*rdyc(i,j)
            enddo
         end if
      enddo

      if ( nt==0 ) then
          do j=js,je
             do i=is,ie
                qdt(i,j,k) = q(i,j,k) + damp*rarea(i,j)*(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))
             enddo
          enddo
      else
          do j=js-nt,je+nt
             do i=is-nt,ie+nt
                q(i,j,k) = q(i,j,k) + damp*rarea(i,j)*(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))
             enddo
          enddo
      endif
   enddo

   enddo

 end subroutine del2_scalar

 subroutine rmse_bias(a, rms, bias, bd, area)
   type(fv_grid_bounds_type), intent(IN) :: bd
   real, intent(in):: a(bd%is:bd%ie,bd%js:bd%je)
   real, intent(IN) :: area(bd%isd:bd%ied,bd%jsd:bd%jed)
   real, intent(out):: rms, bias
   integer:: i,j
   real:: total_area

   integer :: is,  ie,  js,  je

   is  = bd%is
   ie  = bd%ie
   js  = bd%js
   je  = bd%je

   total_area = 4.*pi*radius**2

    rms = 0.
   bias = 0.
   do j=js,je
      do i=is,ie
         bias = bias + area(i,j) * a(i,j)
          rms = rms  + area(i,j) * a(i,j)**2
      enddo
   enddo
   call mp_reduce_sum(bias)
   call mp_reduce_sum(rms)

   bias = bias / total_area
    rms = sqrt( rms / total_area )

 end subroutine rmse_bias


 subroutine corr(a, b, co, bd, area)
 type(fv_grid_bounds_type), intent(IN) :: bd
 real, intent(in):: a(bd%is:bd%ie,bd%js:bd%je), b(bd%is:bd%ie,bd%js:bd%je)
 real, intent(IN) :: area(bd%isd:bd%ied,bd%jsd:bd%jed)
 real, intent(out):: co
 real:: m_a, m_b, std_a, std_b
 integer:: i,j
 real:: total_area

   integer :: is,  ie,  js,  je

   is  = bd%is
   ie  = bd%ie
   js  = bd%js
   je  = bd%je

   total_area = 4.*pi*radius**2

! Compute standard deviation:
   call std(a, m_a, std_a, bd, area)
   call std(b, m_b, std_b, bd, area)

! Compute correlation:
   co = 0.
   do j=js,je
      do i=is,ie
         co = co + area(i,j) * (a(i,j)-m_a)*(b(i,j)-m_b)
      enddo
   enddo
   call mp_reduce_sum(co)
   co = co / (total_area*std_a*std_b )

 end subroutine corr

 subroutine std(a, mean, stdv, bd, area)
 type(fv_grid_bounds_type), intent(IN) :: bd
 real,  intent(in):: a(bd%is:bd%ie,bd%js:bd%je)
 real, intent(IN) :: area(bd%isd:bd%ied,bd%jsd:bd%jed)
 real, intent(out):: mean, stdv
 integer:: i,j
 real:: total_area

   integer :: is,  ie,  js,  je

   is  = bd%is
   ie  = bd%ie
   js  = bd%js
   je  = bd%je

   total_area = 4.*pi*radius**2

   mean = 0.
   do j=js,je
      do i=is,ie
         mean = mean + area(i,j) * a(i,j)
      enddo
   enddo
   call mp_reduce_sum(mean)
   mean = mean / total_area

   stdv = 0.
   do j=js,je
      do i=is,ie
         stdv = stdv + area(i,j) * (a(i,j)-mean)**2
      enddo
   enddo
   call mp_reduce_sum(stdv)
   stdv = sqrt( stdv / total_area )

 end subroutine std


end module fv_ada_nudge_mod
